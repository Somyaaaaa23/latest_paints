{"ast":null,"code":"// Product Knowledge Graph - Semantic relationships between products\nexport class ProductKnowledgeGraph {\n  constructor() {\n    this.nodes = new Map();\n    this.edges = new Map();\n    this.relationships = {\n      COMPATIBLE_WITH: 'compatible_with',\n      ALTERNATIVE_TO: 'alternative_to',\n      REQUIRES: 'requires',\n      USED_WITH: 'used_with',\n      CATEGORY: 'category',\n      MATERIAL: 'material',\n      FINISH: 'finish',\n      APPLICATION: 'application'\n    };\n  }\n\n  // Add a product node to the graph\n  addProduct(product) {\n    const nodeId = product.id;\n    this.nodes.set(nodeId, {\n      id: nodeId,\n      type: 'product',\n      data: product,\n      properties: {\n        name: product.name,\n        category: product.category,\n        finish: product.finish,\n        material: product.material || 'paint',\n        vendor: product.vendor\n      }\n    });\n\n    // Initialize edges for this node\n    if (!this.edges.has(nodeId)) {\n      this.edges.set(nodeId, []);\n    }\n  }\n\n  // Add a relationship between two products\n  addRelationship(fromProductId, toProductId, relationshipType, weight = 1.0) {\n    const edge = {\n      from: fromProductId,\n      to: toProductId,\n      type: relationshipType,\n      weight: weight\n    };\n    if (!this.edges.has(fromProductId)) {\n      this.edges.set(fromProductId, []);\n    }\n    this.edges.get(fromProductId).push(edge);\n  }\n\n  // Find products by category\n  findByCategory(category) {\n    const results = [];\n    for (const [, node] of this.nodes) {\n      var _node$properties$cate;\n      if (((_node$properties$cate = node.properties.category) === null || _node$properties$cate === void 0 ? void 0 : _node$properties$cate.toLowerCase()) === category.toLowerCase()) {\n        results.push(node.data);\n      }\n    }\n    return results;\n  }\n\n  // Find products by finish\n  findByFinish(finish) {\n    const results = [];\n    for (const [, node] of this.nodes) {\n      var _node$properties$fini;\n      if (((_node$properties$fini = node.properties.finish) === null || _node$properties$fini === void 0 ? void 0 : _node$properties$fini.toLowerCase()) === finish.toLowerCase()) {\n        results.push(node.data);\n      }\n    }\n    return results;\n  }\n\n  // Find compatible products\n  findCompatibleProducts(productId) {\n    const compatibleProducts = [];\n    const edges = this.edges.get(productId) || [];\n    edges.forEach(edge => {\n      if (edge.type === this.relationships.COMPATIBLE_WITH || edge.type === this.relationships.ALTERNATIVE_TO) {\n        const product = this.nodes.get(edge.to);\n        if (product) {\n          compatibleProducts.push({\n            product: product.data,\n            relationshipType: edge.type,\n            weight: edge.weight\n          });\n        }\n      }\n    });\n    return compatibleProducts;\n  }\n\n  // Find products that require this product\n  findDependentProducts(productId) {\n    const dependents = [];\n    for (const [nodeId, edges] of this.edges) {\n      edges.forEach(edge => {\n        if (edge.to === productId && edge.type === this.relationships.REQUIRES) {\n          const product = this.nodes.get(nodeId);\n          if (product) {\n            dependents.push(product.data);\n          }\n        }\n      });\n    }\n    return dependents;\n  }\n\n  // Semantic search - find products matching multiple criteria\n  semanticSearch(criteria) {\n    const results = [];\n    for (const [, node] of this.nodes) {\n      var _node$properties$cate2, _node$properties$fini2, _node$properties$mate, _node$properties$vend;\n      let score = 0;\n      let matches = 0;\n\n      // Category match\n      if (criteria.category && ((_node$properties$cate2 = node.properties.category) === null || _node$properties$cate2 === void 0 ? void 0 : _node$properties$cate2.toLowerCase()) === criteria.category.toLowerCase()) {\n        score += 30;\n        matches++;\n      }\n\n      // Finish match\n      if (criteria.finish && ((_node$properties$fini2 = node.properties.finish) === null || _node$properties$fini2 === void 0 ? void 0 : _node$properties$fini2.toLowerCase()) === criteria.finish.toLowerCase()) {\n        score += 25;\n        matches++;\n      }\n\n      // Material match\n      if (criteria.material && ((_node$properties$mate = node.properties.material) === null || _node$properties$mate === void 0 ? void 0 : _node$properties$mate.toLowerCase()) === criteria.material.toLowerCase()) {\n        score += 20;\n        matches++;\n      }\n\n      // Vendor match\n      if (criteria.vendor && ((_node$properties$vend = node.properties.vendor) === null || _node$properties$vend === void 0 ? void 0 : _node$properties$vend.toLowerCase()) === criteria.vendor.toLowerCase()) {\n        score += 15;\n        matches++;\n      }\n\n      // Coverage match\n      if (criteria.minCoverage && node.data.coverage >= criteria.minCoverage) {\n        score += 10;\n        matches++;\n      }\n      if (matches > 0) {\n        results.push({\n          product: node.data,\n          score: score,\n          matchCount: matches\n        });\n      }\n    }\n\n    // Sort by score\n    return results.sort((a, b) => b.score - a.score);\n  }\n\n  // Find shortest path between two products (for recommendations)\n  findPath(fromProductId, toProductId, maxDepth = 3) {\n    const visited = new Set();\n    const queue = [[fromProductId]];\n    while (queue.length > 0) {\n      const path = queue.shift();\n      const currentNode = path[path.length - 1];\n      if (currentNode === toProductId) {\n        return path.map(id => {\n          var _this$nodes$get;\n          return (_this$nodes$get = this.nodes.get(id)) === null || _this$nodes$get === void 0 ? void 0 : _this$nodes$get.data;\n        });\n      }\n      if (path.length >= maxDepth) {\n        continue;\n      }\n      if (visited.has(currentNode)) {\n        continue;\n      }\n      visited.add(currentNode);\n      const edges = this.edges.get(currentNode) || [];\n      edges.forEach(edge => {\n        if (!visited.has(edge.to)) {\n          queue.push([...path, edge.to]);\n        }\n      });\n    }\n    return null; // No path found\n  }\n\n  // Get product recommendations based on current selection\n  getRecommendations(productId, limit = 5) {\n    const recommendations = [];\n    const product = this.nodes.get(productId);\n    if (!product) return recommendations;\n\n    // Find compatible products\n    const compatible = this.findCompatibleProducts(productId);\n    recommendations.push(...compatible);\n\n    // Find products in same category\n    const sameCategory = this.findByCategory(product.properties.category);\n    sameCategory.forEach(p => {\n      if (p.id !== productId && !recommendations.some(r => {\n        var _r$product;\n        return ((_r$product = r.product) === null || _r$product === void 0 ? void 0 : _r$product.id) === p.id;\n      })) {\n        recommendations.push({\n          product: p,\n          relationshipType: 'same_category',\n          weight: 0.7\n        });\n      }\n    });\n\n    // Sort by weight and limit\n    return recommendations.sort((a, b) => b.weight - a.weight).slice(0, limit);\n  }\n\n  // Analyze product clusters\n  findClusters() {\n    const clusters = new Map();\n    for (const [, node] of this.nodes) {\n      const category = node.properties.category || 'uncategorized';\n      if (!clusters.has(category)) {\n        clusters.set(category, []);\n      }\n      clusters.get(category).push(node.data);\n    }\n    return clusters;\n  }\n\n  // Get graph statistics\n  getStatistics() {\n    const stats = {\n      totalProducts: this.nodes.size,\n      totalRelationships: 0,\n      categories: new Set(),\n      vendors: new Set(),\n      avgConnectionsPerProduct: 0\n    };\n    for (const [, node] of this.nodes) {\n      if (node.properties.category) stats.categories.add(node.properties.category);\n      if (node.properties.vendor) stats.vendors.add(node.properties.vendor);\n    }\n    for (const [, edges] of this.edges) {\n      stats.totalRelationships += edges.length;\n    }\n    stats.avgConnectionsPerProduct = stats.totalRelationships / this.nodes.size || 0;\n    return {\n      ...stats,\n      categories: Array.from(stats.categories),\n      vendors: Array.from(stats.vendors)\n    };\n  }\n\n  // Export graph for visualization\n  exportGraph() {\n    const nodes = [];\n    const links = [];\n    for (const [id, node] of this.nodes) {\n      nodes.push({\n        id: id,\n        name: node.properties.name,\n        category: node.properties.category,\n        vendor: node.properties.vendor\n      });\n    }\n    for (const [fromId, edges] of this.edges) {\n      edges.forEach(edge => {\n        links.push({\n          source: fromId,\n          target: edge.to,\n          type: edge.type,\n          weight: edge.weight\n        });\n      });\n    }\n    return {\n      nodes,\n      links\n    };\n  }\n}\n\n// Create and initialize knowledge graph\nexport const productKnowledgeGraph = new ProductKnowledgeGraph();\n\n// Helper function to build graph from product repository\nexport function buildKnowledgeGraph(productRepository) {\n  // Add all products as nodes\n  Object.entries(productRepository).forEach(([vendorName, products]) => {\n    products.forEach(product => {\n      productKnowledgeGraph.addProduct({\n        ...product,\n        vendor: vendorName\n      });\n    });\n  });\n\n  // Add relationships based on properties\n  const allProducts = [];\n  Object.entries(productRepository).forEach(([vendorName, products]) => {\n    products.forEach(product => {\n      allProducts.push({\n        ...product,\n        vendor: vendorName\n      });\n    });\n  });\n\n  // Create relationships\n  allProducts.forEach((product1, i) => {\n    allProducts.forEach((product2, j) => {\n      if (i >= j) return; // Avoid duplicates and self-references\n\n      // Same category = compatible\n      if (product1.category === product2.category) {\n        productKnowledgeGraph.addRelationship(product1.id, product2.id, productKnowledgeGraph.relationships.COMPATIBLE_WITH, 0.8);\n      }\n\n      // Same finish = alternative\n      if (product1.finish === product2.finish && product1.category === product2.category) {\n        productKnowledgeGraph.addRelationship(product1.id, product2.id, productKnowledgeGraph.relationships.ALTERNATIVE_TO, 0.9);\n      }\n\n      // Different categories but complementary\n      if (product1.category === 'Exterior' && product2.category === 'Interior') {\n        productKnowledgeGraph.addRelationship(product1.id, product2.id, productKnowledgeGraph.relationships.USED_WITH, 0.6);\n      }\n    });\n  });\n  return productKnowledgeGraph;\n}","map":{"version":3,"names":["ProductKnowledgeGraph","constructor","nodes","Map","edges","relationships","COMPATIBLE_WITH","ALTERNATIVE_TO","REQUIRES","USED_WITH","CATEGORY","MATERIAL","FINISH","APPLICATION","addProduct","product","nodeId","id","set","type","data","properties","name","category","finish","material","vendor","has","addRelationship","fromProductId","toProductId","relationshipType","weight","edge","from","to","get","push","findByCategory","results","node","_node$properties$cate","toLowerCase","findByFinish","_node$properties$fini","findCompatibleProducts","productId","compatibleProducts","forEach","findDependentProducts","dependents","semanticSearch","criteria","_node$properties$cate2","_node$properties$fini2","_node$properties$mate","_node$properties$vend","score","matches","minCoverage","coverage","matchCount","sort","a","b","findPath","maxDepth","visited","Set","queue","length","path","shift","currentNode","map","_this$nodes$get","add","getRecommendations","limit","recommendations","compatible","sameCategory","p","some","r","_r$product","slice","findClusters","clusters","getStatistics","stats","totalProducts","size","totalRelationships","categories","vendors","avgConnectionsPerProduct","Array","exportGraph","links","fromId","source","target","productKnowledgeGraph","buildKnowledgeGraph","productRepository","Object","entries","vendorName","products","allProducts","product1","i","product2","j"],"sources":["C:/Users/BIT/Downloads/RFP/src/utils/ProductKnowledgeGraph.js"],"sourcesContent":["// Product Knowledge Graph - Semantic relationships between products\r\nexport class ProductKnowledgeGraph {\r\n  constructor() {\r\n    this.nodes = new Map();\r\n    this.edges = new Map();\r\n    this.relationships = {\r\n      COMPATIBLE_WITH: 'compatible_with',\r\n      ALTERNATIVE_TO: 'alternative_to',\r\n      REQUIRES: 'requires',\r\n      USED_WITH: 'used_with',\r\n      CATEGORY: 'category',\r\n      MATERIAL: 'material',\r\n      FINISH: 'finish',\r\n      APPLICATION: 'application'\r\n    };\r\n  }\r\n  \r\n  // Add a product node to the graph\r\n  addProduct(product) {\r\n    const nodeId = product.id;\r\n    this.nodes.set(nodeId, {\r\n      id: nodeId,\r\n      type: 'product',\r\n      data: product,\r\n      properties: {\r\n        name: product.name,\r\n        category: product.category,\r\n        finish: product.finish,\r\n        material: product.material || 'paint',\r\n        vendor: product.vendor\r\n      }\r\n    });\r\n    \r\n    // Initialize edges for this node\r\n    if (!this.edges.has(nodeId)) {\r\n      this.edges.set(nodeId, []);\r\n    }\r\n  }\r\n  \r\n  // Add a relationship between two products\r\n  addRelationship(fromProductId, toProductId, relationshipType, weight = 1.0) {\r\n    const edge = {\r\n      from: fromProductId,\r\n      to: toProductId,\r\n      type: relationshipType,\r\n      weight: weight\r\n    };\r\n    \r\n    if (!this.edges.has(fromProductId)) {\r\n      this.edges.set(fromProductId, []);\r\n    }\r\n    \r\n    this.edges.get(fromProductId).push(edge);\r\n  }\r\n  \r\n  // Find products by category\r\n  findByCategory(category) {\r\n    const results = [];\r\n    for (const [, node] of this.nodes) {\r\n      if (node.properties.category?.toLowerCase() === category.toLowerCase()) {\r\n        results.push(node.data);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  \r\n  // Find products by finish\r\n  findByFinish(finish) {\r\n    const results = [];\r\n    for (const [, node] of this.nodes) {\r\n      if (node.properties.finish?.toLowerCase() === finish.toLowerCase()) {\r\n        results.push(node.data);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  \r\n  // Find compatible products\r\n  findCompatibleProducts(productId) {\r\n    const compatibleProducts = [];\r\n    const edges = this.edges.get(productId) || [];\r\n    \r\n    edges.forEach(edge => {\r\n      if (edge.type === this.relationships.COMPATIBLE_WITH || \r\n          edge.type === this.relationships.ALTERNATIVE_TO) {\r\n        const product = this.nodes.get(edge.to);\r\n        if (product) {\r\n          compatibleProducts.push({\r\n            product: product.data,\r\n            relationshipType: edge.type,\r\n            weight: edge.weight\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    return compatibleProducts;\r\n  }\r\n  \r\n  // Find products that require this product\r\n  findDependentProducts(productId) {\r\n    const dependents = [];\r\n    \r\n    for (const [nodeId, edges] of this.edges) {\r\n      edges.forEach(edge => {\r\n        if (edge.to === productId && edge.type === this.relationships.REQUIRES) {\r\n          const product = this.nodes.get(nodeId);\r\n          if (product) {\r\n            dependents.push(product.data);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    \r\n    return dependents;\r\n  }\r\n  \r\n  // Semantic search - find products matching multiple criteria\r\n  semanticSearch(criteria) {\r\n    const results = [];\r\n    \r\n    for (const [, node] of this.nodes) {\r\n      let score = 0;\r\n      let matches = 0;\r\n      \r\n      // Category match\r\n      if (criteria.category && node.properties.category?.toLowerCase() === criteria.category.toLowerCase()) {\r\n        score += 30;\r\n        matches++;\r\n      }\r\n      \r\n      // Finish match\r\n      if (criteria.finish && node.properties.finish?.toLowerCase() === criteria.finish.toLowerCase()) {\r\n        score += 25;\r\n        matches++;\r\n      }\r\n      \r\n      // Material match\r\n      if (criteria.material && node.properties.material?.toLowerCase() === criteria.material.toLowerCase()) {\r\n        score += 20;\r\n        matches++;\r\n      }\r\n      \r\n      // Vendor match\r\n      if (criteria.vendor && node.properties.vendor?.toLowerCase() === criteria.vendor.toLowerCase()) {\r\n        score += 15;\r\n        matches++;\r\n      }\r\n      \r\n      // Coverage match\r\n      if (criteria.minCoverage && node.data.coverage >= criteria.minCoverage) {\r\n        score += 10;\r\n        matches++;\r\n      }\r\n      \r\n      if (matches > 0) {\r\n        results.push({\r\n          product: node.data,\r\n          score: score,\r\n          matchCount: matches\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Sort by score\r\n    return results.sort((a, b) => b.score - a.score);\r\n  }\r\n  \r\n  // Find shortest path between two products (for recommendations)\r\n  findPath(fromProductId, toProductId, maxDepth = 3) {\r\n    const visited = new Set();\r\n    const queue = [[fromProductId]];\r\n    \r\n    while (queue.length > 0) {\r\n      const path = queue.shift();\r\n      const currentNode = path[path.length - 1];\r\n      \r\n      if (currentNode === toProductId) {\r\n        return path.map(id => this.nodes.get(id)?.data);\r\n      }\r\n      \r\n      if (path.length >= maxDepth) {\r\n        continue;\r\n      }\r\n      \r\n      if (visited.has(currentNode)) {\r\n        continue;\r\n      }\r\n      \r\n      visited.add(currentNode);\r\n      \r\n      const edges = this.edges.get(currentNode) || [];\r\n      edges.forEach(edge => {\r\n        if (!visited.has(edge.to)) {\r\n          queue.push([...path, edge.to]);\r\n        }\r\n      });\r\n    }\r\n    \r\n    return null; // No path found\r\n  }\r\n  \r\n  // Get product recommendations based on current selection\r\n  getRecommendations(productId, limit = 5) {\r\n    const recommendations = [];\r\n    const product = this.nodes.get(productId);\r\n    \r\n    if (!product) return recommendations;\r\n    \r\n    // Find compatible products\r\n    const compatible = this.findCompatibleProducts(productId);\r\n    recommendations.push(...compatible);\r\n    \r\n    // Find products in same category\r\n    const sameCategory = this.findByCategory(product.properties.category);\r\n    sameCategory.forEach(p => {\r\n      if (p.id !== productId && !recommendations.some(r => r.product?.id === p.id)) {\r\n        recommendations.push({\r\n          product: p,\r\n          relationshipType: 'same_category',\r\n          weight: 0.7\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Sort by weight and limit\r\n    return recommendations\r\n      .sort((a, b) => b.weight - a.weight)\r\n      .slice(0, limit);\r\n  }\r\n  \r\n  // Analyze product clusters\r\n  findClusters() {\r\n    const clusters = new Map();\r\n    \r\n    for (const [, node] of this.nodes) {\r\n      const category = node.properties.category || 'uncategorized';\r\n      \r\n      if (!clusters.has(category)) {\r\n        clusters.set(category, []);\r\n      }\r\n      \r\n      clusters.get(category).push(node.data);\r\n    }\r\n    \r\n    return clusters;\r\n  }\r\n  \r\n  // Get graph statistics\r\n  getStatistics() {\r\n    const stats = {\r\n      totalProducts: this.nodes.size,\r\n      totalRelationships: 0,\r\n      categories: new Set(),\r\n      vendors: new Set(),\r\n      avgConnectionsPerProduct: 0\r\n    };\r\n    \r\n    for (const [, node] of this.nodes) {\r\n      if (node.properties.category) stats.categories.add(node.properties.category);\r\n      if (node.properties.vendor) stats.vendors.add(node.properties.vendor);\r\n    }\r\n    \r\n    for (const [, edges] of this.edges) {\r\n      stats.totalRelationships += edges.length;\r\n    }\r\n    \r\n    stats.avgConnectionsPerProduct = stats.totalRelationships / this.nodes.size || 0;\r\n    \r\n    return {\r\n      ...stats,\r\n      categories: Array.from(stats.categories),\r\n      vendors: Array.from(stats.vendors)\r\n    };\r\n  }\r\n  \r\n  // Export graph for visualization\r\n  exportGraph() {\r\n    const nodes = [];\r\n    const links = [];\r\n    \r\n    for (const [id, node] of this.nodes) {\r\n      nodes.push({\r\n        id: id,\r\n        name: node.properties.name,\r\n        category: node.properties.category,\r\n        vendor: node.properties.vendor\r\n      });\r\n    }\r\n    \r\n    for (const [fromId, edges] of this.edges) {\r\n      edges.forEach(edge => {\r\n        links.push({\r\n          source: fromId,\r\n          target: edge.to,\r\n          type: edge.type,\r\n          weight: edge.weight\r\n        });\r\n      });\r\n    }\r\n    \r\n    return { nodes, links };\r\n  }\r\n}\r\n\r\n// Create and initialize knowledge graph\r\nexport const productKnowledgeGraph = new ProductKnowledgeGraph();\r\n\r\n// Helper function to build graph from product repository\r\nexport function buildKnowledgeGraph(productRepository) {\r\n  // Add all products as nodes\r\n  Object.entries(productRepository).forEach(([vendorName, products]) => {\r\n    products.forEach(product => {\r\n      productKnowledgeGraph.addProduct({\r\n        ...product,\r\n        vendor: vendorName\r\n      });\r\n    });\r\n  });\r\n  \r\n  // Add relationships based on properties\r\n  const allProducts = [];\r\n  Object.entries(productRepository).forEach(([vendorName, products]) => {\r\n    products.forEach(product => {\r\n      allProducts.push({ ...product, vendor: vendorName });\r\n    });\r\n  });\r\n  \r\n  // Create relationships\r\n  allProducts.forEach((product1, i) => {\r\n    allProducts.forEach((product2, j) => {\r\n      if (i >= j) return; // Avoid duplicates and self-references\r\n      \r\n      // Same category = compatible\r\n      if (product1.category === product2.category) {\r\n        productKnowledgeGraph.addRelationship(\r\n          product1.id,\r\n          product2.id,\r\n          productKnowledgeGraph.relationships.COMPATIBLE_WITH,\r\n          0.8\r\n        );\r\n      }\r\n      \r\n      // Same finish = alternative\r\n      if (product1.finish === product2.finish && product1.category === product2.category) {\r\n        productKnowledgeGraph.addRelationship(\r\n          product1.id,\r\n          product2.id,\r\n          productKnowledgeGraph.relationships.ALTERNATIVE_TO,\r\n          0.9\r\n        );\r\n      }\r\n      \r\n      // Different categories but complementary\r\n      if (product1.category === 'Exterior' && product2.category === 'Interior') {\r\n        productKnowledgeGraph.addRelationship(\r\n          product1.id,\r\n          product2.id,\r\n          productKnowledgeGraph.relationships.USED_WITH,\r\n          0.6\r\n        );\r\n      }\r\n    });\r\n  });\r\n  \r\n  return productKnowledgeGraph;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}