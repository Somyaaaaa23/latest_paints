{"ast":null,"code":"// Learning Memory - Store and recall past RFP matches using similarity\nexport class LearningMemory {\n  constructor() {\n    this.memoryKey = 'rfp_learning_memory';\n    this.memory = this.loadMemory();\n    this.similarityThreshold = 0.75; // 75% similarity to recall\n  }\n\n  // Load memory from localStorage\n  loadMemory() {\n    try {\n      const stored = localStorage.getItem(this.memoryKey);\n      return stored ? JSON.parse(stored) : [];\n    } catch (error) {\n      console.error('Failed to load memory:', error);\n      return [];\n    }\n  }\n\n  // Save memory to localStorage\n  saveMemory() {\n    try {\n      localStorage.setItem(this.memoryKey, JSON.stringify(this.memory));\n      console.log(`ðŸ’¾ Learning Memory: Saved ${this.memory.length} past RFPs`);\n    } catch (error) {\n      console.error('Failed to save memory:', error);\n    }\n  }\n\n  // Store a new RFP match\n  storeMatch(rfpData) {\n    var _rfpData$pricingDetai, _rfpData$winProbabili;\n    const memoryEntry = {\n      id: `MEM_${Date.now()}`,\n      timestamp: new Date().toISOString(),\n      rfpTitle: rfpData.rfpTitle || 'Untitled RFP',\n      requirements: rfpData.requirements || [],\n      totalArea: rfpData.totalSqFt || 0,\n      deadline: rfpData.deadline,\n      matchScore: rfpData.overallMatchScore || 0,\n      recommendedVendor: rfpData.recommendedVendor,\n      finalPrice: ((_rfpData$pricingDetai = rfpData.pricingDetails) === null || _rfpData$pricingDetai === void 0 ? void 0 : _rfpData$pricingDetai.finalPrice) || 0,\n      winProbability: ((_rfpData$winProbabili = rfpData.winProbability) === null || _rfpData$winProbabili === void 0 ? void 0 : _rfpData$winProbabili.probability) || 0,\n      status: rfpData.status || 'completed',\n      // Store feature vector for similarity matching\n      features: this.extractFeatures(rfpData)\n    };\n    this.memory.push(memoryEntry);\n\n    // Keep only last 100 entries for performance\n    if (this.memory.length > 100) {\n      this.memory = this.memory.slice(-100);\n    }\n    this.saveMemory();\n    console.log(`ðŸ§  Learning Memory: Stored RFP \"${memoryEntry.rfpTitle}\"`);\n    return memoryEntry;\n  }\n\n  // Extract features from RFP for similarity comparison\n  extractFeatures(rfpData) {\n    var _rfpData$requirements, _rfpData$pricingDetai2, _rfpData$analysis, _rfpData$analysis2;\n    const features = {\n      totalArea: rfpData.totalSqFt || 0,\n      requirementCount: ((_rfpData$requirements = rfpData.requirements) === null || _rfpData$requirements === void 0 ? void 0 : _rfpData$requirements.length) || 0,\n      avgMatchScore: rfpData.overallMatchScore || 0,\n      priceRange: this.getPriceRange(((_rfpData$pricingDetai2 = rfpData.pricingDetails) === null || _rfpData$pricingDetai2 === void 0 ? void 0 : _rfpData$pricingDetai2.finalPrice) || 0),\n      urgency: ((_rfpData$analysis = rfpData.analysis) === null || _rfpData$analysis === void 0 ? void 0 : _rfpData$analysis.urgency) || 'standard',\n      complexity: ((_rfpData$analysis2 = rfpData.analysis) === null || _rfpData$analysis2 === void 0 ? void 0 : _rfpData$analysis2.complexity) || 'medium',\n      // Text features\n      keywords: this.extractKeywords(rfpData.rfpTitle || ''),\n      categories: this.extractCategories(rfpData.requirements || [])\n    };\n    return features;\n  }\n\n  // Extract keywords from text\n  extractKeywords(text) {\n    const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'];\n    const words = text.toLowerCase().replace(/[^\\w\\s]/g, '').split(/\\s+/).filter(word => word.length > 3 && !stopWords.includes(word));\n    return [...new Set(words)]; // Unique keywords\n  }\n\n  // Extract categories from requirements\n  extractCategories(requirements) {\n    const categories = new Set();\n    requirements.forEach(req => {\n      var _req$specs, _req$specs2;\n      if ((_req$specs = req.specs) !== null && _req$specs !== void 0 && _req$specs.category) categories.add(req.specs.category.toLowerCase());\n      if ((_req$specs2 = req.specs) !== null && _req$specs2 !== void 0 && _req$specs2.finish) categories.add(req.specs.finish.toLowerCase());\n    });\n    return Array.from(categories);\n  }\n\n  // Get price range bucket\n  getPriceRange(price) {\n    if (price < 30000) return 'low';\n    if (price < 70000) return 'medium';\n    if (price < 120000) return 'high';\n    return 'very_high';\n  }\n\n  // Calculate cosine similarity between two feature vectors\n  calculateSimilarity(features1, features2) {\n    let totalSimilarity = 0;\n    let weights = 0;\n\n    // Area similarity (weight: 0.25)\n    const areaDiff = Math.abs(features1.totalArea - features2.totalArea);\n    const maxArea = Math.max(features1.totalArea, features2.totalArea);\n    const areaSimilarity = maxArea > 0 ? 1 - areaDiff / maxArea : 1;\n    totalSimilarity += areaSimilarity * 0.25;\n    weights += 0.25;\n\n    // Price range similarity (weight: 0.20)\n    const priceSimilarity = features1.priceRange === features2.priceRange ? 1 : 0.5;\n    totalSimilarity += priceSimilarity * 0.20;\n    weights += 0.20;\n\n    // Urgency similarity (weight: 0.15)\n    const urgencySimilarity = features1.urgency === features2.urgency ? 1 : 0.5;\n    totalSimilarity += urgencySimilarity * 0.15;\n    weights += 0.15;\n\n    // Complexity similarity (weight: 0.15)\n    const complexitySimilarity = features1.complexity === features2.complexity ? 1 : 0.5;\n    totalSimilarity += complexitySimilarity * 0.15;\n    weights += 0.15;\n\n    // Keyword similarity (weight: 0.15)\n    const keywordSimilarity = this.jaccardSimilarity(features1.keywords, features2.keywords);\n    totalSimilarity += keywordSimilarity * 0.15;\n    weights += 0.15;\n\n    // Category similarity (weight: 0.10)\n    const categorySimilarity = this.jaccardSimilarity(features1.categories, features2.categories);\n    totalSimilarity += categorySimilarity * 0.10;\n    weights += 0.10;\n    return totalSimilarity / weights;\n  }\n\n  // Jaccard similarity for sets\n  jaccardSimilarity(set1, set2) {\n    if (set1.length === 0 && set2.length === 0) return 1;\n    if (set1.length === 0 || set2.length === 0) return 0;\n    const intersection = set1.filter(item => set2.includes(item)).length;\n    const union = new Set([...set1, ...set2]).size;\n    return union > 0 ? intersection / union : 0;\n  }\n\n  // Recall similar past RFPs\n  recallSimilar(currentRfpData, limit = 5) {\n    if (this.memory.length === 0) {\n      console.log('ðŸ§  Learning Memory: No past RFPs to recall');\n      return [];\n    }\n    const currentFeatures = this.extractFeatures(currentRfpData);\n    const similarities = [];\n    this.memory.forEach(pastRfp => {\n      const similarity = this.calculateSimilarity(currentFeatures, pastRfp.features);\n      if (similarity >= this.similarityThreshold) {\n        similarities.push({\n          ...pastRfp,\n          similarity: similarity,\n          similarityPercent: Math.round(similarity * 100)\n        });\n      }\n    });\n\n    // Sort by similarity (highest first)\n    similarities.sort((a, b) => b.similarity - a.similarity);\n    const recalled = similarities.slice(0, limit);\n    if (recalled.length > 0) {\n      console.log(`ðŸ§  Learning Memory: Recalled ${recalled.length} similar past RFPs`);\n      recalled.forEach(rfp => {\n        console.log(`  - \"${rfp.rfpTitle}\" (${rfp.similarityPercent}% similar)`);\n      });\n    } else {\n      console.log('ðŸ§  Learning Memory: No similar past RFPs found');\n    }\n    return recalled;\n  }\n\n  // Get insights from similar past RFPs\n  getInsights(similarRfps) {\n    if (similarRfps.length === 0) {\n      return {\n        hasInsights: false,\n        message: 'No similar past RFPs found for comparison'\n      };\n    }\n    const avgMatchScore = similarRfps.reduce((sum, rfp) => sum + rfp.matchScore, 0) / similarRfps.length;\n    const avgWinProbability = similarRfps.reduce((sum, rfp) => sum + rfp.winProbability, 0) / similarRfps.length;\n    const avgPrice = similarRfps.reduce((sum, rfp) => sum + rfp.finalPrice, 0) / similarRfps.length;\n    const vendorCounts = {};\n    similarRfps.forEach(rfp => {\n      vendorCounts[rfp.recommendedVendor] = (vendorCounts[rfp.recommendedVendor] || 0) + 1;\n    });\n    const mostCommonVendor = Object.entries(vendorCounts).sort((a, b) => b[1] - a[1])[0];\n    return {\n      hasInsights: true,\n      similarCount: similarRfps.length,\n      avgMatchScore: Math.round(avgMatchScore),\n      avgWinProbability: Math.round(avgWinProbability),\n      avgPrice: Math.round(avgPrice),\n      mostCommonVendor: mostCommonVendor ? mostCommonVendor[0] : null,\n      vendorFrequency: mostCommonVendor ? mostCommonVendor[1] : 0,\n      recommendations: this.generateRecommendations(similarRfps, avgMatchScore, avgWinProbability)\n    };\n  }\n\n  // Generate recommendations based on past RFPs\n  generateRecommendations(similarRfps, avgMatchScore, avgWinProbability) {\n    const recommendations = [];\n    if (avgMatchScore > 85) {\n      recommendations.push('Similar past RFPs had high match scores - good alignment expected');\n    } else if (avgMatchScore < 70) {\n      recommendations.push('Similar past RFPs had lower match scores - consider spec adjustments');\n    }\n    if (avgWinProbability > 75) {\n      recommendations.push('Historical data suggests high win probability for similar RFPs');\n    } else if (avgWinProbability < 50) {\n      recommendations.push('Similar RFPs had lower win rates - review pricing strategy');\n    }\n    const wonCount = similarRfps.filter(rfp => rfp.status === 'won').length;\n    if (wonCount > similarRfps.length * 0.7) {\n      recommendations.push('Strong historical success rate with similar RFPs');\n    }\n    return recommendations;\n  }\n\n  // Get memory statistics\n  getStatistics() {\n    if (this.memory.length === 0) {\n      return {\n        totalRfps: 0,\n        avgMatchScore: 0,\n        avgWinProbability: 0,\n        topVendor: null\n      };\n    }\n    const avgMatchScore = this.memory.reduce((sum, rfp) => sum + rfp.matchScore, 0) / this.memory.length;\n    const avgWinProbability = this.memory.reduce((sum, rfp) => sum + rfp.winProbability, 0) / this.memory.length;\n    const vendorCounts = {};\n    this.memory.forEach(rfp => {\n      vendorCounts[rfp.recommendedVendor] = (vendorCounts[rfp.recommendedVendor] || 0) + 1;\n    });\n    const topVendor = Object.entries(vendorCounts).sort((a, b) => b[1] - a[1])[0];\n    return {\n      totalRfps: this.memory.length,\n      avgMatchScore: Math.round(avgMatchScore),\n      avgWinProbability: Math.round(avgWinProbability),\n      topVendor: topVendor ? topVendor[0] : null,\n      topVendorCount: topVendor ? topVendor[1] : 0\n    };\n  }\n\n  // Clear all memory\n  clearMemory() {\n    this.memory = [];\n    localStorage.removeItem(this.memoryKey);\n    console.log('ðŸ§  Learning Memory: Cleared all stored RFPs');\n  }\n\n  // Export memory for backup\n  exportMemory() {\n    return JSON.stringify(this.memory, null, 2);\n  }\n\n  // Import memory from backup\n  importMemory(jsonString) {\n    try {\n      const imported = JSON.parse(jsonString);\n      if (Array.isArray(imported)) {\n        this.memory = imported;\n        this.saveMemory();\n        console.log(`ðŸ§  Learning Memory: Imported ${imported.length} RFPs`);\n        return true;\n      }\n      return false;\n    } catch (error) {\n      console.error('Failed to import memory:', error);\n      return false;\n    }\n  }\n}\n\n// Create singleton instance\nexport const learningMemory = new LearningMemory();","map":{"version":3,"names":["LearningMemory","constructor","memoryKey","memory","loadMemory","similarityThreshold","stored","localStorage","getItem","JSON","parse","error","console","saveMemory","setItem","stringify","log","length","storeMatch","rfpData","_rfpData$pricingDetai","_rfpData$winProbabili","memoryEntry","id","Date","now","timestamp","toISOString","rfpTitle","requirements","totalArea","totalSqFt","deadline","matchScore","overallMatchScore","recommendedVendor","finalPrice","pricingDetails","winProbability","probability","status","features","extractFeatures","push","slice","_rfpData$requirements","_rfpData$pricingDetai2","_rfpData$analysis","_rfpData$analysis2","requirementCount","avgMatchScore","priceRange","getPriceRange","urgency","analysis","complexity","keywords","extractKeywords","categories","extractCategories","text","stopWords","words","toLowerCase","replace","split","filter","word","includes","Set","forEach","req","_req$specs","_req$specs2","specs","category","add","finish","Array","from","price","calculateSimilarity","features1","features2","totalSimilarity","weights","areaDiff","Math","abs","maxArea","max","areaSimilarity","priceSimilarity","urgencySimilarity","complexitySimilarity","keywordSimilarity","jaccardSimilarity","categorySimilarity","set1","set2","intersection","item","union","size","recallSimilar","currentRfpData","limit","currentFeatures","similarities","pastRfp","similarity","similarityPercent","round","sort","a","b","recalled","rfp","getInsights","similarRfps","hasInsights","message","reduce","sum","avgWinProbability","avgPrice","vendorCounts","mostCommonVendor","Object","entries","similarCount","vendorFrequency","recommendations","generateRecommendations","wonCount","getStatistics","totalRfps","topVendor","topVendorCount","clearMemory","removeItem","exportMemory","importMemory","jsonString","imported","isArray","learningMemory"],"sources":["C:/Users/BIT/Downloads/RFP/src/utils/LearningMemory.js"],"sourcesContent":["// Learning Memory - Store and recall past RFP matches using similarity\r\nexport class LearningMemory {\r\n  constructor() {\r\n    this.memoryKey = 'rfp_learning_memory';\r\n    this.memory = this.loadMemory();\r\n    this.similarityThreshold = 0.75; // 75% similarity to recall\r\n  }\r\n\r\n  // Load memory from localStorage\r\n  loadMemory() {\r\n    try {\r\n      const stored = localStorage.getItem(this.memoryKey);\r\n      return stored ? JSON.parse(stored) : [];\r\n    } catch (error) {\r\n      console.error('Failed to load memory:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  // Save memory to localStorage\r\n  saveMemory() {\r\n    try {\r\n      localStorage.setItem(this.memoryKey, JSON.stringify(this.memory));\r\n      console.log(`ðŸ’¾ Learning Memory: Saved ${this.memory.length} past RFPs`);\r\n    } catch (error) {\r\n      console.error('Failed to save memory:', error);\r\n    }\r\n  }\r\n\r\n  // Store a new RFP match\r\n  storeMatch(rfpData) {\r\n    const memoryEntry = {\r\n      id: `MEM_${Date.now()}`,\r\n      timestamp: new Date().toISOString(),\r\n      rfpTitle: rfpData.rfpTitle || 'Untitled RFP',\r\n      requirements: rfpData.requirements || [],\r\n      totalArea: rfpData.totalSqFt || 0,\r\n      deadline: rfpData.deadline,\r\n      matchScore: rfpData.overallMatchScore || 0,\r\n      recommendedVendor: rfpData.recommendedVendor,\r\n      finalPrice: rfpData.pricingDetails?.finalPrice || 0,\r\n      winProbability: rfpData.winProbability?.probability || 0,\r\n      status: rfpData.status || 'completed',\r\n      // Store feature vector for similarity matching\r\n      features: this.extractFeatures(rfpData)\r\n    };\r\n\r\n    this.memory.push(memoryEntry);\r\n    \r\n    // Keep only last 100 entries for performance\r\n    if (this.memory.length > 100) {\r\n      this.memory = this.memory.slice(-100);\r\n    }\r\n\r\n    this.saveMemory();\r\n    console.log(`ðŸ§  Learning Memory: Stored RFP \"${memoryEntry.rfpTitle}\"`);\r\n    \r\n    return memoryEntry;\r\n  }\r\n\r\n  // Extract features from RFP for similarity comparison\r\n  extractFeatures(rfpData) {\r\n    const features = {\r\n      totalArea: rfpData.totalSqFt || 0,\r\n      requirementCount: rfpData.requirements?.length || 0,\r\n      avgMatchScore: rfpData.overallMatchScore || 0,\r\n      priceRange: this.getPriceRange(rfpData.pricingDetails?.finalPrice || 0),\r\n      urgency: rfpData.analysis?.urgency || 'standard',\r\n      complexity: rfpData.analysis?.complexity || 'medium',\r\n      // Text features\r\n      keywords: this.extractKeywords(rfpData.rfpTitle || ''),\r\n      categories: this.extractCategories(rfpData.requirements || [])\r\n    };\r\n\r\n    return features;\r\n  }\r\n\r\n  // Extract keywords from text\r\n  extractKeywords(text) {\r\n    const stopWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'];\r\n    const words = text.toLowerCase()\r\n      .replace(/[^\\w\\s]/g, '')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 3 && !stopWords.includes(word));\r\n    \r\n    return [...new Set(words)]; // Unique keywords\r\n  }\r\n\r\n  // Extract categories from requirements\r\n  extractCategories(requirements) {\r\n    const categories = new Set();\r\n    requirements.forEach(req => {\r\n      if (req.specs?.category) categories.add(req.specs.category.toLowerCase());\r\n      if (req.specs?.finish) categories.add(req.specs.finish.toLowerCase());\r\n    });\r\n    return Array.from(categories);\r\n  }\r\n\r\n  // Get price range bucket\r\n  getPriceRange(price) {\r\n    if (price < 30000) return 'low';\r\n    if (price < 70000) return 'medium';\r\n    if (price < 120000) return 'high';\r\n    return 'very_high';\r\n  }\r\n\r\n  // Calculate cosine similarity between two feature vectors\r\n  calculateSimilarity(features1, features2) {\r\n    let totalSimilarity = 0;\r\n    let weights = 0;\r\n\r\n    // Area similarity (weight: 0.25)\r\n    const areaDiff = Math.abs(features1.totalArea - features2.totalArea);\r\n    const maxArea = Math.max(features1.totalArea, features2.totalArea);\r\n    const areaSimilarity = maxArea > 0 ? 1 - (areaDiff / maxArea) : 1;\r\n    totalSimilarity += areaSimilarity * 0.25;\r\n    weights += 0.25;\r\n\r\n    // Price range similarity (weight: 0.20)\r\n    const priceSimilarity = features1.priceRange === features2.priceRange ? 1 : 0.5;\r\n    totalSimilarity += priceSimilarity * 0.20;\r\n    weights += 0.20;\r\n\r\n    // Urgency similarity (weight: 0.15)\r\n    const urgencySimilarity = features1.urgency === features2.urgency ? 1 : 0.5;\r\n    totalSimilarity += urgencySimilarity * 0.15;\r\n    weights += 0.15;\r\n\r\n    // Complexity similarity (weight: 0.15)\r\n    const complexitySimilarity = features1.complexity === features2.complexity ? 1 : 0.5;\r\n    totalSimilarity += complexitySimilarity * 0.15;\r\n    weights += 0.15;\r\n\r\n    // Keyword similarity (weight: 0.15)\r\n    const keywordSimilarity = this.jaccardSimilarity(features1.keywords, features2.keywords);\r\n    totalSimilarity += keywordSimilarity * 0.15;\r\n    weights += 0.15;\r\n\r\n    // Category similarity (weight: 0.10)\r\n    const categorySimilarity = this.jaccardSimilarity(features1.categories, features2.categories);\r\n    totalSimilarity += categorySimilarity * 0.10;\r\n    weights += 0.10;\r\n\r\n    return totalSimilarity / weights;\r\n  }\r\n\r\n  // Jaccard similarity for sets\r\n  jaccardSimilarity(set1, set2) {\r\n    if (set1.length === 0 && set2.length === 0) return 1;\r\n    if (set1.length === 0 || set2.length === 0) return 0;\r\n\r\n    const intersection = set1.filter(item => set2.includes(item)).length;\r\n    const union = new Set([...set1, ...set2]).size;\r\n\r\n    return union > 0 ? intersection / union : 0;\r\n  }\r\n\r\n  // Recall similar past RFPs\r\n  recallSimilar(currentRfpData, limit = 5) {\r\n    if (this.memory.length === 0) {\r\n      console.log('ðŸ§  Learning Memory: No past RFPs to recall');\r\n      return [];\r\n    }\r\n\r\n    const currentFeatures = this.extractFeatures(currentRfpData);\r\n    const similarities = [];\r\n\r\n    this.memory.forEach(pastRfp => {\r\n      const similarity = this.calculateSimilarity(currentFeatures, pastRfp.features);\r\n      \r\n      if (similarity >= this.similarityThreshold) {\r\n        similarities.push({\r\n          ...pastRfp,\r\n          similarity: similarity,\r\n          similarityPercent: Math.round(similarity * 100)\r\n        });\r\n      }\r\n    });\r\n\r\n    // Sort by similarity (highest first)\r\n    similarities.sort((a, b) => b.similarity - a.similarity);\r\n\r\n    const recalled = similarities.slice(0, limit);\r\n    \r\n    if (recalled.length > 0) {\r\n      console.log(`ðŸ§  Learning Memory: Recalled ${recalled.length} similar past RFPs`);\r\n      recalled.forEach(rfp => {\r\n        console.log(`  - \"${rfp.rfpTitle}\" (${rfp.similarityPercent}% similar)`);\r\n      });\r\n    } else {\r\n      console.log('ðŸ§  Learning Memory: No similar past RFPs found');\r\n    }\r\n\r\n    return recalled;\r\n  }\r\n\r\n  // Get insights from similar past RFPs\r\n  getInsights(similarRfps) {\r\n    if (similarRfps.length === 0) {\r\n      return {\r\n        hasInsights: false,\r\n        message: 'No similar past RFPs found for comparison'\r\n      };\r\n    }\r\n\r\n    const avgMatchScore = similarRfps.reduce((sum, rfp) => sum + rfp.matchScore, 0) / similarRfps.length;\r\n    const avgWinProbability = similarRfps.reduce((sum, rfp) => sum + rfp.winProbability, 0) / similarRfps.length;\r\n    const avgPrice = similarRfps.reduce((sum, rfp) => sum + rfp.finalPrice, 0) / similarRfps.length;\r\n    \r\n    const vendorCounts = {};\r\n    similarRfps.forEach(rfp => {\r\n      vendorCounts[rfp.recommendedVendor] = (vendorCounts[rfp.recommendedVendor] || 0) + 1;\r\n    });\r\n    \r\n    const mostCommonVendor = Object.entries(vendorCounts)\r\n      .sort((a, b) => b[1] - a[1])[0];\r\n\r\n    return {\r\n      hasInsights: true,\r\n      similarCount: similarRfps.length,\r\n      avgMatchScore: Math.round(avgMatchScore),\r\n      avgWinProbability: Math.round(avgWinProbability),\r\n      avgPrice: Math.round(avgPrice),\r\n      mostCommonVendor: mostCommonVendor ? mostCommonVendor[0] : null,\r\n      vendorFrequency: mostCommonVendor ? mostCommonVendor[1] : 0,\r\n      recommendations: this.generateRecommendations(similarRfps, avgMatchScore, avgWinProbability)\r\n    };\r\n  }\r\n\r\n  // Generate recommendations based on past RFPs\r\n  generateRecommendations(similarRfps, avgMatchScore, avgWinProbability) {\r\n    const recommendations = [];\r\n\r\n    if (avgMatchScore > 85) {\r\n      recommendations.push('Similar past RFPs had high match scores - good alignment expected');\r\n    } else if (avgMatchScore < 70) {\r\n      recommendations.push('Similar past RFPs had lower match scores - consider spec adjustments');\r\n    }\r\n\r\n    if (avgWinProbability > 75) {\r\n      recommendations.push('Historical data suggests high win probability for similar RFPs');\r\n    } else if (avgWinProbability < 50) {\r\n      recommendations.push('Similar RFPs had lower win rates - review pricing strategy');\r\n    }\r\n\r\n    const wonCount = similarRfps.filter(rfp => rfp.status === 'won').length;\r\n    if (wonCount > similarRfps.length * 0.7) {\r\n      recommendations.push('Strong historical success rate with similar RFPs');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n\r\n  // Get memory statistics\r\n  getStatistics() {\r\n    if (this.memory.length === 0) {\r\n      return {\r\n        totalRfps: 0,\r\n        avgMatchScore: 0,\r\n        avgWinProbability: 0,\r\n        topVendor: null\r\n      };\r\n    }\r\n\r\n    const avgMatchScore = this.memory.reduce((sum, rfp) => sum + rfp.matchScore, 0) / this.memory.length;\r\n    const avgWinProbability = this.memory.reduce((sum, rfp) => sum + rfp.winProbability, 0) / this.memory.length;\r\n    \r\n    const vendorCounts = {};\r\n    this.memory.forEach(rfp => {\r\n      vendorCounts[rfp.recommendedVendor] = (vendorCounts[rfp.recommendedVendor] || 0) + 1;\r\n    });\r\n    \r\n    const topVendor = Object.entries(vendorCounts)\r\n      .sort((a, b) => b[1] - a[1])[0];\r\n\r\n    return {\r\n      totalRfps: this.memory.length,\r\n      avgMatchScore: Math.round(avgMatchScore),\r\n      avgWinProbability: Math.round(avgWinProbability),\r\n      topVendor: topVendor ? topVendor[0] : null,\r\n      topVendorCount: topVendor ? topVendor[1] : 0\r\n    };\r\n  }\r\n\r\n  // Clear all memory\r\n  clearMemory() {\r\n    this.memory = [];\r\n    localStorage.removeItem(this.memoryKey);\r\n    console.log('ðŸ§  Learning Memory: Cleared all stored RFPs');\r\n  }\r\n\r\n  // Export memory for backup\r\n  exportMemory() {\r\n    return JSON.stringify(this.memory, null, 2);\r\n  }\r\n\r\n  // Import memory from backup\r\n  importMemory(jsonString) {\r\n    try {\r\n      const imported = JSON.parse(jsonString);\r\n      if (Array.isArray(imported)) {\r\n        this.memory = imported;\r\n        this.saveMemory();\r\n        console.log(`ðŸ§  Learning Memory: Imported ${imported.length} RFPs`);\r\n        return true;\r\n      }\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Failed to import memory:', error);\r\n      return false;\r\n    }\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const learningMemory = new LearningMemory();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}