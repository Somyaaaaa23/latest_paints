{"ast":null,"code":"// Enhanced NLP Processor - Advanced text processing and entity extraction\nexport class EnhancedNLP {\n  constructor() {\n    this.name = \"Enhanced NLP Processor\";\n\n    // Industry-specific patterns\n    this.patterns = {\n      area: /(\\d+(?:,\\d{3})*)\\s*(?:sq\\s*ft|sqft|square\\s*feet|sq\\.?\\s*ft\\.?)/gi,\n      coverage: /(\\d+)\\s*(?:sq\\s*ft\\s*per\\s*liter|sqft\\/liter|sq\\.?\\s*ft\\.?\\/l)/gi,\n      durability: /(\\d+)\\s*(?:years?|yrs?)/gi,\n      cost: /\\$\\s*(\\d+(?:,\\d{3})*(?:\\.\\d{2})?)/g,\n      deadline: /(?:deadline|due|completion|submit\\s*by).*?(\\d{4}-\\d{2}-\\d{2}|\\d{1,2}\\/\\d{1,2}\\/\\d{4}|\\d{1,2}-\\d{1,2}-\\d{4})/i,\n      finish: /(matt|matte|silk|satin|gloss|glossy|semi-gloss|eggshell|flat)/gi,\n      material: /(pvc|acrylic|emulsion|enamel|latex|oil-based|water-based)/gi,\n      standard: /(is\\s*\\d+|iso\\s*\\d+|astm\\s*\\w+|bs\\s*\\d+)/gi,\n      voltage: /(\\d+)\\s*(?:v|volt|volts|kv)/gi,\n      certification: /(ce|ul|rohs|reach|iso\\s*certified)/gi\n    };\n\n    // Synonym dictionary for paint industry\n    this.synonyms = {\n      'matt': ['matte', 'flat', 'non-glossy'],\n      'silk': ['satin', 'semi-gloss', 'eggshell'],\n      'gloss': ['glossy', 'shiny', 'high-gloss'],\n      'exterior': ['external', 'outdoor', 'outside', 'facade'],\n      'interior': ['internal', 'indoor', 'inside'],\n      'weather-resistant': ['weatherproof', 'weather-proof', 'all-weather', 'outdoor-grade'],\n      'durable': ['long-lasting', 'hard-wearing', 'robust', 'resilient'],\n      'coverage': ['spread', 'covering', 'application-rate', 'spreading-rate'],\n      'emulsion': ['paint', 'coating', 'finish', 'latex'],\n      'primer': ['undercoat', 'base-coat', 'sealer'],\n      'topcoat': ['finish-coat', 'final-coat', 'top-layer']\n    };\n  }\n\n  // Extract all entities from RFP text\n  extractEntities(text) {\n    const entities = {\n      areas: this.extractAreas(text),\n      coverages: this.extractCoverages(text),\n      durabilities: this.extractDurabilities(text),\n      costs: this.extractCosts(text),\n      deadline: this.extractDeadline(text),\n      finishes: this.extractFinishes(text),\n      materials: this.extractMaterials(text),\n      standards: this.extractStandards(text),\n      voltages: this.extractVoltages(text),\n      certifications: this.extractCertifications(text)\n    };\n    return entities;\n  }\n\n  // Extract area values\n  extractAreas(text) {\n    const matches = [...text.matchAll(this.patterns.area)];\n    return matches.map(match => ({\n      value: parseInt(match[1].replace(/,/g, '')),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Extract coverage values\n  extractCoverages(text) {\n    const matches = [...text.matchAll(this.patterns.coverage)];\n    return matches.map(match => ({\n      value: parseInt(match[1]),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Extract durability values\n  extractDurabilities(text) {\n    const matches = [...text.matchAll(this.patterns.durability)];\n    return matches.map(match => ({\n      value: parseInt(match[1]),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Extract cost values\n  extractCosts(text) {\n    const matches = [...text.matchAll(this.patterns.cost)];\n    return matches.map(match => ({\n      value: parseFloat(match[1].replace(/,/g, '')),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Extract deadline\n  extractDeadline(text) {\n    const match = text.match(this.patterns.deadline);\n    if (!match) return null;\n    const dateStr = match[1];\n    let deadline = null;\n    if (dateStr.includes('/')) {\n      const [month, day, year] = dateStr.split('/');\n      deadline = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\n    } else if (dateStr.includes('-') && dateStr.length === 10) {\n      deadline = dateStr;\n    }\n    return {\n      value: deadline,\n      raw: match[0],\n      position: match.index\n    };\n  }\n\n  // Extract finish types\n  extractFinishes(text) {\n    const matches = [...text.matchAll(this.patterns.finish)];\n    return matches.map(match => ({\n      value: match[1].toLowerCase(),\n      raw: match[0],\n      position: match.index,\n      synonyms: this.synonyms[match[1].toLowerCase()] || []\n    }));\n  }\n\n  // Extract materials\n  extractMaterials(text) {\n    const matches = [...text.matchAll(this.patterns.material)];\n    return matches.map(match => ({\n      value: match[1].toLowerCase(),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Extract standards\n  extractStandards(text) {\n    const matches = [...text.matchAll(this.patterns.standard)];\n    return matches.map(match => ({\n      value: match[1].toUpperCase(),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Extract voltages\n  extractVoltages(text) {\n    const matches = [...text.matchAll(this.patterns.voltage)];\n    return matches.map(match => ({\n      value: parseInt(match[1]),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Extract certifications\n  extractCertifications(text) {\n    const matches = [...text.matchAll(this.patterns.certification)];\n    return matches.map(match => ({\n      value: match[1].toUpperCase(),\n      raw: match[0],\n      position: match.index\n    }));\n  }\n\n  // Normalize text (remove extra spaces, lowercase, etc.)\n  normalizeText(text) {\n    return text.toLowerCase().replace(/\\s+/g, ' ').trim();\n  }\n\n  // Tokenize text into words\n  tokenize(text) {\n    return text.toLowerCase().split(/\\W+/).filter(word => word.length > 0);\n  }\n\n  // Remove stop words\n  removeStopWords(tokens) {\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been', 'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might', 'must', 'can', 'this', 'that', 'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they']);\n    return tokens.filter(token => !stopWords.has(token));\n  }\n\n  // Extract key phrases (n-grams)\n  extractKeyPhrases(text, n = 2) {\n    const tokens = this.tokenize(text);\n    const phrases = [];\n    for (let i = 0; i <= tokens.length - n; i++) {\n      const phrase = tokens.slice(i, i + n).join(' ');\n      phrases.push(phrase);\n    }\n    return phrases;\n  }\n\n  // Calculate term frequency\n  termFrequency(text) {\n    const tokens = this.tokenize(text);\n    const frequency = {};\n    tokens.forEach(token => {\n      frequency[token] = (frequency[token] || 0) + 1;\n    });\n    return frequency;\n  }\n\n  // Find most important terms (TF-IDF-like)\n  extractImportantTerms(text, topN = 10) {\n    const tokens = this.removeStopWords(this.tokenize(text));\n    const frequency = {};\n    tokens.forEach(token => {\n      if (token.length > 2) {\n        frequency[token] = (frequency[token] || 0) + 1;\n      }\n    });\n    return Object.entries(frequency).sort((a, b) => b[1] - a[1]).slice(0, topN).map(([term, freq]) => ({\n      term,\n      frequency: freq\n    }));\n  }\n\n  // Sentiment analysis (simple positive/negative)\n  analyzeSentiment(text) {\n    const positiveWords = new Set(['excellent', 'good', 'great', 'best', 'quality', 'premium', 'superior', 'reliable', 'durable', 'efficient', 'effective', 'high-grade']);\n    const negativeWords = new Set(['poor', 'bad', 'worst', 'inferior', 'low-quality', 'unreliable', 'defective', 'faulty', 'inadequate', 'substandard']);\n    const tokens = this.tokenize(text);\n    let positiveCount = 0;\n    let negativeCount = 0;\n    tokens.forEach(token => {\n      if (positiveWords.has(token)) positiveCount++;\n      if (negativeWords.has(token)) negativeCount++;\n    });\n    const total = positiveCount + negativeCount;\n    if (total === 0) return {\n      sentiment: 'neutral',\n      score: 0\n    };\n    const score = (positiveCount - negativeCount) / total;\n    const sentiment = score > 0.2 ? 'positive' : score < -0.2 ? 'negative' : 'neutral';\n    return {\n      sentiment,\n      score,\n      positiveCount,\n      negativeCount\n    };\n  }\n\n  // Classify requirement type\n  classifyRequirementType(text) {\n    const exteriorKeywords = ['exterior', 'external', 'outdoor', 'outside', 'facade', 'wall'];\n    const interiorKeywords = ['interior', 'internal', 'indoor', 'inside', 'room', 'ceiling'];\n    const lowerText = text.toLowerCase();\n    const hasExterior = exteriorKeywords.some(kw => lowerText.includes(kw));\n    const hasInterior = interiorKeywords.some(kw => lowerText.includes(kw));\n    if (hasExterior && hasInterior) return 'mixed';\n    if (hasExterior) return 'exterior';\n    if (hasInterior) return 'interior';\n    return 'unknown';\n  }\n\n  // Extract urgency level\n  extractUrgency(text) {\n    const urgentKeywords = ['urgent', 'asap', 'immediate', 'rush', 'emergency', 'critical'];\n    const highKeywords = ['high priority', 'important', 'soon', 'quickly'];\n    const lowerText = text.toLowerCase();\n    if (urgentKeywords.some(kw => lowerText.includes(kw))) {\n      return {\n        level: 'urgent',\n        confidence: 0.9\n      };\n    }\n    if (highKeywords.some(kw => lowerText.includes(kw))) {\n      return {\n        level: 'high',\n        confidence: 0.8\n      };\n    }\n    return {\n      level: 'standard',\n      confidence: 0.7\n    };\n  }\n\n  // Comprehensive RFP analysis\n  analyzeRFP(text) {\n    const entities = this.extractEntities(text);\n    const importantTerms = this.extractImportantTerms(text);\n    const sentiment = this.analyzeSentiment(text);\n    const requirementType = this.classifyRequirementType(text);\n    const urgency = this.extractUrgency(text);\n    return {\n      entities,\n      importantTerms,\n      sentiment,\n      requirementType,\n      urgency,\n      summary: {\n        totalAreas: entities.areas.length,\n        totalCosts: entities.costs.length,\n        hasDeadline: entities.deadline !== null,\n        finishTypes: entities.finishes.map(f => f.value),\n        materials: entities.materials.map(m => m.value),\n        standards: entities.standards.map(s => s.value)\n      }\n    };\n  }\n}\n\n// Create singleton instance\nexport const enhancedNLP = new EnhancedNLP();","map":{"version":3,"names":["EnhancedNLP","constructor","name","patterns","area","coverage","durability","cost","deadline","finish","material","standard","voltage","certification","synonyms","extractEntities","text","entities","areas","extractAreas","coverages","extractCoverages","durabilities","extractDurabilities","costs","extractCosts","extractDeadline","finishes","extractFinishes","materials","extractMaterials","standards","extractStandards","voltages","extractVoltages","certifications","extractCertifications","matches","matchAll","map","match","value","parseInt","replace","raw","position","index","parseFloat","dateStr","includes","month","day","year","split","padStart","length","toLowerCase","toUpperCase","normalizeText","trim","tokenize","filter","word","removeStopWords","tokens","stopWords","Set","token","has","extractKeyPhrases","n","phrases","i","phrase","slice","join","push","termFrequency","frequency","forEach","extractImportantTerms","topN","Object","entries","sort","a","b","term","freq","analyzeSentiment","positiveWords","negativeWords","positiveCount","negativeCount","total","sentiment","score","classifyRequirementType","exteriorKeywords","interiorKeywords","lowerText","hasExterior","some","kw","hasInterior","extractUrgency","urgentKeywords","highKeywords","level","confidence","analyzeRFP","importantTerms","requirementType","urgency","summary","totalAreas","totalCosts","hasDeadline","finishTypes","f","m","s","enhancedNLP"],"sources":["C:/Users/BIT/Downloads/RFP/src/utils/EnhancedNLP.js"],"sourcesContent":["// Enhanced NLP Processor - Advanced text processing and entity extraction\r\nexport class EnhancedNLP {\r\n  constructor() {\r\n    this.name = \"Enhanced NLP Processor\";\r\n    \r\n    // Industry-specific patterns\r\n    this.patterns = {\r\n      area: /(\\d+(?:,\\d{3})*)\\s*(?:sq\\s*ft|sqft|square\\s*feet|sq\\.?\\s*ft\\.?)/gi,\r\n      coverage: /(\\d+)\\s*(?:sq\\s*ft\\s*per\\s*liter|sqft\\/liter|sq\\.?\\s*ft\\.?\\/l)/gi,\r\n      durability: /(\\d+)\\s*(?:years?|yrs?)/gi,\r\n      cost: /\\$\\s*(\\d+(?:,\\d{3})*(?:\\.\\d{2})?)/g,\r\n      deadline: /(?:deadline|due|completion|submit\\s*by).*?(\\d{4}-\\d{2}-\\d{2}|\\d{1,2}\\/\\d{1,2}\\/\\d{4}|\\d{1,2}-\\d{1,2}-\\d{4})/i,\r\n      finish: /(matt|matte|silk|satin|gloss|glossy|semi-gloss|eggshell|flat)/gi,\r\n      material: /(pvc|acrylic|emulsion|enamel|latex|oil-based|water-based)/gi,\r\n      standard: /(is\\s*\\d+|iso\\s*\\d+|astm\\s*\\w+|bs\\s*\\d+)/gi,\r\n      voltage: /(\\d+)\\s*(?:v|volt|volts|kv)/gi,\r\n      certification: /(ce|ul|rohs|reach|iso\\s*certified)/gi\r\n    };\r\n\r\n    // Synonym dictionary for paint industry\r\n    this.synonyms = {\r\n      'matt': ['matte', 'flat', 'non-glossy'],\r\n      'silk': ['satin', 'semi-gloss', 'eggshell'],\r\n      'gloss': ['glossy', 'shiny', 'high-gloss'],\r\n      'exterior': ['external', 'outdoor', 'outside', 'facade'],\r\n      'interior': ['internal', 'indoor', 'inside'],\r\n      'weather-resistant': ['weatherproof', 'weather-proof', 'all-weather', 'outdoor-grade'],\r\n      'durable': ['long-lasting', 'hard-wearing', 'robust', 'resilient'],\r\n      'coverage': ['spread', 'covering', 'application-rate', 'spreading-rate'],\r\n      'emulsion': ['paint', 'coating', 'finish', 'latex'],\r\n      'primer': ['undercoat', 'base-coat', 'sealer'],\r\n      'topcoat': ['finish-coat', 'final-coat', 'top-layer']\r\n    };\r\n  }\r\n\r\n  // Extract all entities from RFP text\r\n  extractEntities(text) {\r\n    const entities = {\r\n      areas: this.extractAreas(text),\r\n      coverages: this.extractCoverages(text),\r\n      durabilities: this.extractDurabilities(text),\r\n      costs: this.extractCosts(text),\r\n      deadline: this.extractDeadline(text),\r\n      finishes: this.extractFinishes(text),\r\n      materials: this.extractMaterials(text),\r\n      standards: this.extractStandards(text),\r\n      voltages: this.extractVoltages(text),\r\n      certifications: this.extractCertifications(text)\r\n    };\r\n\r\n    return entities;\r\n  }\r\n\r\n  // Extract area values\r\n  extractAreas(text) {\r\n    const matches = [...text.matchAll(this.patterns.area)];\r\n    return matches.map(match => ({\r\n      value: parseInt(match[1].replace(/,/g, '')),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Extract coverage values\r\n  extractCoverages(text) {\r\n    const matches = [...text.matchAll(this.patterns.coverage)];\r\n    return matches.map(match => ({\r\n      value: parseInt(match[1]),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Extract durability values\r\n  extractDurabilities(text) {\r\n    const matches = [...text.matchAll(this.patterns.durability)];\r\n    return matches.map(match => ({\r\n      value: parseInt(match[1]),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Extract cost values\r\n  extractCosts(text) {\r\n    const matches = [...text.matchAll(this.patterns.cost)];\r\n    return matches.map(match => ({\r\n      value: parseFloat(match[1].replace(/,/g, '')),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Extract deadline\r\n  extractDeadline(text) {\r\n    const match = text.match(this.patterns.deadline);\r\n    if (!match) return null;\r\n\r\n    const dateStr = match[1];\r\n    let deadline = null;\r\n\r\n    if (dateStr.includes('/')) {\r\n      const [month, day, year] = dateStr.split('/');\r\n      deadline = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;\r\n    } else if (dateStr.includes('-') && dateStr.length === 10) {\r\n      deadline = dateStr;\r\n    }\r\n\r\n    return {\r\n      value: deadline,\r\n      raw: match[0],\r\n      position: match.index\r\n    };\r\n  }\r\n\r\n  // Extract finish types\r\n  extractFinishes(text) {\r\n    const matches = [...text.matchAll(this.patterns.finish)];\r\n    return matches.map(match => ({\r\n      value: match[1].toLowerCase(),\r\n      raw: match[0],\r\n      position: match.index,\r\n      synonyms: this.synonyms[match[1].toLowerCase()] || []\r\n    }));\r\n  }\r\n\r\n  // Extract materials\r\n  extractMaterials(text) {\r\n    const matches = [...text.matchAll(this.patterns.material)];\r\n    return matches.map(match => ({\r\n      value: match[1].toLowerCase(),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Extract standards\r\n  extractStandards(text) {\r\n    const matches = [...text.matchAll(this.patterns.standard)];\r\n    return matches.map(match => ({\r\n      value: match[1].toUpperCase(),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Extract voltages\r\n  extractVoltages(text) {\r\n    const matches = [...text.matchAll(this.patterns.voltage)];\r\n    return matches.map(match => ({\r\n      value: parseInt(match[1]),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Extract certifications\r\n  extractCertifications(text) {\r\n    const matches = [...text.matchAll(this.patterns.certification)];\r\n    return matches.map(match => ({\r\n      value: match[1].toUpperCase(),\r\n      raw: match[0],\r\n      position: match.index\r\n    }));\r\n  }\r\n\r\n  // Normalize text (remove extra spaces, lowercase, etc.)\r\n  normalizeText(text) {\r\n    return text\r\n      .toLowerCase()\r\n      .replace(/\\s+/g, ' ')\r\n      .trim();\r\n  }\r\n\r\n  // Tokenize text into words\r\n  tokenize(text) {\r\n    return text\r\n      .toLowerCase()\r\n      .split(/\\W+/)\r\n      .filter(word => word.length > 0);\r\n  }\r\n\r\n  // Remove stop words\r\n  removeStopWords(tokens) {\r\n    const stopWords = new Set([\r\n      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',\r\n      'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were', 'been',\r\n      'be', 'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would',\r\n      'should', 'could', 'may', 'might', 'must', 'can', 'this', 'that',\r\n      'these', 'those', 'i', 'you', 'he', 'she', 'it', 'we', 'they'\r\n    ]);\r\n\r\n    return tokens.filter(token => !stopWords.has(token));\r\n  }\r\n\r\n  // Extract key phrases (n-grams)\r\n  extractKeyPhrases(text, n = 2) {\r\n    const tokens = this.tokenize(text);\r\n    const phrases = [];\r\n\r\n    for (let i = 0; i <= tokens.length - n; i++) {\r\n      const phrase = tokens.slice(i, i + n).join(' ');\r\n      phrases.push(phrase);\r\n    }\r\n\r\n    return phrases;\r\n  }\r\n\r\n  // Calculate term frequency\r\n  termFrequency(text) {\r\n    const tokens = this.tokenize(text);\r\n    const frequency = {};\r\n\r\n    tokens.forEach(token => {\r\n      frequency[token] = (frequency[token] || 0) + 1;\r\n    });\r\n\r\n    return frequency;\r\n  }\r\n\r\n  // Find most important terms (TF-IDF-like)\r\n  extractImportantTerms(text, topN = 10) {\r\n    const tokens = this.removeStopWords(this.tokenize(text));\r\n    const frequency = {};\r\n\r\n    tokens.forEach(token => {\r\n      if (token.length > 2) {\r\n        frequency[token] = (frequency[token] || 0) + 1;\r\n      }\r\n    });\r\n\r\n    return Object.entries(frequency)\r\n      .sort((a, b) => b[1] - a[1])\r\n      .slice(0, topN)\r\n      .map(([term, freq]) => ({ term, frequency: freq }));\r\n  }\r\n\r\n  // Sentiment analysis (simple positive/negative)\r\n  analyzeSentiment(text) {\r\n    const positiveWords = new Set([\r\n      'excellent', 'good', 'great', 'best', 'quality', 'premium', 'superior',\r\n      'reliable', 'durable', 'efficient', 'effective', 'high-grade'\r\n    ]);\r\n\r\n    const negativeWords = new Set([\r\n      'poor', 'bad', 'worst', 'inferior', 'low-quality', 'unreliable',\r\n      'defective', 'faulty', 'inadequate', 'substandard'\r\n    ]);\r\n\r\n    const tokens = this.tokenize(text);\r\n    let positiveCount = 0;\r\n    let negativeCount = 0;\r\n\r\n    tokens.forEach(token => {\r\n      if (positiveWords.has(token)) positiveCount++;\r\n      if (negativeWords.has(token)) negativeCount++;\r\n    });\r\n\r\n    const total = positiveCount + negativeCount;\r\n    if (total === 0) return { sentiment: 'neutral', score: 0 };\r\n\r\n    const score = (positiveCount - negativeCount) / total;\r\n    const sentiment = score > 0.2 ? 'positive' : score < -0.2 ? 'negative' : 'neutral';\r\n\r\n    return { sentiment, score, positiveCount, negativeCount };\r\n  }\r\n\r\n  // Classify requirement type\r\n  classifyRequirementType(text) {\r\n    const exteriorKeywords = ['exterior', 'external', 'outdoor', 'outside', 'facade', 'wall'];\r\n    const interiorKeywords = ['interior', 'internal', 'indoor', 'inside', 'room', 'ceiling'];\r\n    \r\n    const lowerText = text.toLowerCase();\r\n    const hasExterior = exteriorKeywords.some(kw => lowerText.includes(kw));\r\n    const hasInterior = interiorKeywords.some(kw => lowerText.includes(kw));\r\n\r\n    if (hasExterior && hasInterior) return 'mixed';\r\n    if (hasExterior) return 'exterior';\r\n    if (hasInterior) return 'interior';\r\n    return 'unknown';\r\n  }\r\n\r\n  // Extract urgency level\r\n  extractUrgency(text) {\r\n    const urgentKeywords = ['urgent', 'asap', 'immediate', 'rush', 'emergency', 'critical'];\r\n    const highKeywords = ['high priority', 'important', 'soon', 'quickly'];\r\n    \r\n    const lowerText = text.toLowerCase();\r\n    \r\n    if (urgentKeywords.some(kw => lowerText.includes(kw))) {\r\n      return { level: 'urgent', confidence: 0.9 };\r\n    }\r\n    if (highKeywords.some(kw => lowerText.includes(kw))) {\r\n      return { level: 'high', confidence: 0.8 };\r\n    }\r\n    \r\n    return { level: 'standard', confidence: 0.7 };\r\n  }\r\n\r\n  // Comprehensive RFP analysis\r\n  analyzeRFP(text) {\r\n    const entities = this.extractEntities(text);\r\n    const importantTerms = this.extractImportantTerms(text);\r\n    const sentiment = this.analyzeSentiment(text);\r\n    const requirementType = this.classifyRequirementType(text);\r\n    const urgency = this.extractUrgency(text);\r\n\r\n    return {\r\n      entities,\r\n      importantTerms,\r\n      sentiment,\r\n      requirementType,\r\n      urgency,\r\n      summary: {\r\n        totalAreas: entities.areas.length,\r\n        totalCosts: entities.costs.length,\r\n        hasDeadline: entities.deadline !== null,\r\n        finishTypes: entities.finishes.map(f => f.value),\r\n        materials: entities.materials.map(m => m.value),\r\n        standards: entities.standards.map(s => s.value)\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const enhancedNLP = new EnhancedNLP();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}