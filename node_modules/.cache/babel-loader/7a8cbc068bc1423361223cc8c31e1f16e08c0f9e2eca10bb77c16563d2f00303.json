{"ast":null,"code":"// Semantic Matcher - Advanced similarity calculations\nexport class SemanticMatcher {\n  constructor() {\n    this.name = \"Semantic Matcher\";\n  }\n\n  // Cosine Similarity - Core algorithm for semantic matching\n  cosineSimilarity(vecA, vecB) {\n    if (vecA.length !== vecB.length) {\n      throw new Error('Vectors must have the same length');\n    }\n    const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);\n    const magA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));\n    const magB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));\n    if (magA === 0 || magB === 0) return 0;\n    return dotProduct / (magA * magB);\n  }\n\n  // Convert text to simple feature vector (TF-IDF-like approach)\n  textToVector(text, vocabulary) {\n    const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2);\n    const vector = new Array(vocabulary.length).fill(0);\n    words.forEach(word => {\n      const index = vocabulary.indexOf(word);\n      if (index !== -1) {\n        vector[index]++;\n      }\n    });\n\n    // Normalize vector\n    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n    return magnitude > 0 ? vector.map(v => v / magnitude) : vector;\n  }\n\n  // Build vocabulary from corpus\n  buildVocabulary(texts) {\n    const allWords = new Set();\n    texts.forEach(text => {\n      const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2);\n      words.forEach(word => allWords.add(word));\n    });\n    return Array.from(allWords).sort();\n  }\n\n  // Semantic similarity between two texts\n  calculateTextSimilarity(text1, text2) {\n    const vocabulary = this.buildVocabulary([text1, text2]);\n    const vec1 = this.textToVector(text1, vocabulary);\n    const vec2 = this.textToVector(text2, vocabulary);\n    return this.cosineSimilarity(vec1, vec2);\n  }\n\n  // Enhanced spec matching with semantic similarity\n  semanticSpecMatch(requirement, product) {\n    const scores = {\n      finishSimilarity: 0,\n      categorySimilarity: 0,\n      overallSimilarity: 0\n    };\n\n    // Finish type semantic matching\n    if (requirement.finish && product.finish) {\n      scores.finishSimilarity = this.calculateTextSimilarity(requirement.finish, product.finish);\n    }\n\n    // Category semantic matching\n    if (requirement.type && product.category) {\n      scores.categorySimilarity = this.calculateTextSimilarity(requirement.type, product.category);\n    }\n\n    // Overall semantic similarity\n    const reqText = `${requirement.finish || ''} ${requirement.type || ''} ${requirement.coverage || ''} ${requirement.durability || ''}`;\n    const prodText = `${product.finish || ''} ${product.category || ''} ${product.coverage || ''} ${product.durability || ''}`;\n    scores.overallSimilarity = this.calculateTextSimilarity(reqText, prodText);\n    return scores;\n  }\n\n  // Fuzzy string matching (Levenshtein distance)\n  levenshteinDistance(str1, str2) {\n    const len1 = str1.length;\n    const len2 = str2.length;\n    const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\n    for (let i = 0; i <= len1; i++) matrix[i][0] = i;\n    for (let j = 0; j <= len2; j++) matrix[0][j] = j;\n    for (let i = 1; i <= len1; i++) {\n      for (let j = 1; j <= len2; j++) {\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[i][j] = Math.min(matrix[i - 1][j] + 1,\n        // deletion\n        matrix[i][j - 1] + 1,\n        // insertion\n        matrix[i - 1][j - 1] + cost // substitution\n        );\n      }\n    }\n    return matrix[len1][len2];\n  }\n\n  // Fuzzy match score (0-1 scale)\n  fuzzyMatchScore(str1, str2) {\n    const distance = this.levenshteinDistance(str1.toLowerCase(), str2.toLowerCase());\n    const maxLen = Math.max(str1.length, str2.length);\n    return maxLen > 0 ? 1 - distance / maxLen : 0;\n  }\n\n  // Synonym detection for paint industry terms\n  getSynonyms(term) {\n    const synonymMap = {\n      'matt': ['matte', 'flat', 'non-glossy'],\n      'silk': ['satin', 'semi-gloss', 'eggshell'],\n      'gloss': ['glossy', 'shiny', 'high-gloss'],\n      'exterior': ['external', 'outdoor', 'outside'],\n      'interior': ['internal', 'indoor', 'inside'],\n      'weather-resistant': ['weatherproof', 'weather-proof', 'all-weather'],\n      'durable': ['long-lasting', 'hard-wearing', 'robust'],\n      'coverage': ['spread', 'covering', 'application-rate'],\n      'emulsion': ['paint', 'coating', 'finish']\n    };\n    const lowerTerm = term.toLowerCase();\n\n    // Check if term is a key\n    if (synonymMap[lowerTerm]) {\n      return [lowerTerm, ...synonymMap[lowerTerm]];\n    }\n\n    // Check if term is in any synonym list\n    for (const [key, synonyms] of Object.entries(synonymMap)) {\n      if (synonyms.includes(lowerTerm)) {\n        return [key, ...synonyms];\n      }\n    }\n    return [lowerTerm];\n  }\n\n  // Enhanced matching with synonym support\n  matchWithSynonyms(term1, term2) {\n    const synonyms1 = this.getSynonyms(term1);\n    const synonyms2 = this.getSynonyms(term2);\n\n    // Check for exact match in synonym lists\n    for (const syn1 of synonyms1) {\n      for (const syn2 of synonyms2) {\n        if (syn1 === syn2) {\n          return {\n            match: true,\n            score: 1.0,\n            type: 'exact'\n          };\n        }\n      }\n    }\n\n    // Check for fuzzy match\n    let bestScore = 0;\n    for (const syn1 of synonyms1) {\n      for (const syn2 of synonyms2) {\n        const score = this.fuzzyMatchScore(syn1, syn2);\n        if (score > bestScore) {\n          bestScore = score;\n        }\n      }\n    }\n    if (bestScore > 0.8) {\n      return {\n        match: true,\n        score: bestScore,\n        type: 'fuzzy'\n      };\n    }\n    return {\n      match: false,\n      score: bestScore,\n      type: 'none'\n    };\n  }\n\n  // Jaccard similarity for set-based comparison\n  jaccardSimilarity(set1, set2) {\n    const intersection = new Set([...set1].filter(x => set2.has(x)));\n    const union = new Set([...set1, ...set2]);\n    return union.size > 0 ? intersection.size / union.size : 0;\n  }\n\n  // Extract keywords from text\n  extractKeywords(text) {\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by']);\n    const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2 && !stopWords.has(w));\n    return new Set(words);\n  }\n\n  // Keyword-based similarity\n  keywordSimilarity(text1, text2) {\n    const keywords1 = this.extractKeywords(text1);\n    const keywords2 = this.extractKeywords(text2);\n    return this.jaccardSimilarity(keywords1, keywords2);\n  }\n\n  // Comprehensive similarity score combining multiple methods\n  comprehensiveSimilarity(text1, text2) {\n    const cosine = this.calculateTextSimilarity(text1, text2);\n    const keyword = this.keywordSimilarity(text1, text2);\n    const fuzzy = this.fuzzyMatchScore(text1, text2);\n\n    // Weighted combination\n    return {\n      cosine: cosine,\n      keyword: keyword,\n      fuzzy: fuzzy,\n      combined: cosine * 0.5 + keyword * 0.3 + fuzzy * 0.2,\n      breakdown: {\n        'Cosine Similarity': `${(cosine * 100).toFixed(1)}%`,\n        'Keyword Match': `${(keyword * 100).toFixed(1)}%`,\n        'Fuzzy Match': `${(fuzzy * 100).toFixed(1)}%`\n      }\n    };\n  }\n}\n\n// Create singleton instance\nexport const semanticMatcher = new SemanticMatcher();","map":{"version":3,"names":["SemanticMatcher","constructor","name","cosineSimilarity","vecA","vecB","length","Error","dotProduct","reduce","sum","a","i","magA","Math","sqrt","magB","b","textToVector","text","vocabulary","words","toLowerCase","split","filter","w","vector","Array","fill","forEach","word","index","indexOf","magnitude","val","map","v","buildVocabulary","texts","allWords","Set","add","from","sort","calculateTextSimilarity","text1","text2","vec1","vec2","semanticSpecMatch","requirement","product","scores","finishSimilarity","categorySimilarity","overallSimilarity","finish","type","category","reqText","coverage","durability","prodText","levenshteinDistance","str1","str2","len1","len2","matrix","j","cost","min","fuzzyMatchScore","distance","maxLen","max","getSynonyms","term","synonymMap","lowerTerm","key","synonyms","Object","entries","includes","matchWithSynonyms","term1","term2","synonyms1","synonyms2","syn1","syn2","match","score","bestScore","jaccardSimilarity","set1","set2","intersection","x","has","union","size","extractKeywords","stopWords","keywordSimilarity","keywords1","keywords2","comprehensiveSimilarity","cosine","keyword","fuzzy","combined","breakdown","toFixed","semanticMatcher"],"sources":["C:/Users/BIT/Downloads/RFP/src/utils/SemanticMatcher.js"],"sourcesContent":["// Semantic Matcher - Advanced similarity calculations\r\nexport class SemanticMatcher {\r\n  constructor() {\r\n    this.name = \"Semantic Matcher\";\r\n  }\r\n\r\n  // Cosine Similarity - Core algorithm for semantic matching\r\n  cosineSimilarity(vecA, vecB) {\r\n    if (vecA.length !== vecB.length) {\r\n      throw new Error('Vectors must have the same length');\r\n    }\r\n\r\n    const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);\r\n    const magA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));\r\n    const magB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));\r\n\r\n    if (magA === 0 || magB === 0) return 0;\r\n    \r\n    return dotProduct / (magA * magB);\r\n  }\r\n\r\n  // Convert text to simple feature vector (TF-IDF-like approach)\r\n  textToVector(text, vocabulary) {\r\n    const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2);\r\n    const vector = new Array(vocabulary.length).fill(0);\r\n    \r\n    words.forEach(word => {\r\n      const index = vocabulary.indexOf(word);\r\n      if (index !== -1) {\r\n        vector[index]++;\r\n      }\r\n    });\r\n    \r\n    // Normalize vector\r\n    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\r\n    return magnitude > 0 ? vector.map(v => v / magnitude) : vector;\r\n  }\r\n\r\n  // Build vocabulary from corpus\r\n  buildVocabulary(texts) {\r\n    const allWords = new Set();\r\n    \r\n    texts.forEach(text => {\r\n      const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2);\r\n      words.forEach(word => allWords.add(word));\r\n    });\r\n    \r\n    return Array.from(allWords).sort();\r\n  }\r\n\r\n  // Semantic similarity between two texts\r\n  calculateTextSimilarity(text1, text2) {\r\n    const vocabulary = this.buildVocabulary([text1, text2]);\r\n    const vec1 = this.textToVector(text1, vocabulary);\r\n    const vec2 = this.textToVector(text2, vocabulary);\r\n    \r\n    return this.cosineSimilarity(vec1, vec2);\r\n  }\r\n\r\n  // Enhanced spec matching with semantic similarity\r\n  semanticSpecMatch(requirement, product) {\r\n    const scores = {\r\n      finishSimilarity: 0,\r\n      categorySimilarity: 0,\r\n      overallSimilarity: 0\r\n    };\r\n\r\n    // Finish type semantic matching\r\n    if (requirement.finish && product.finish) {\r\n      scores.finishSimilarity = this.calculateTextSimilarity(\r\n        requirement.finish,\r\n        product.finish\r\n      );\r\n    }\r\n\r\n    // Category semantic matching\r\n    if (requirement.type && product.category) {\r\n      scores.categorySimilarity = this.calculateTextSimilarity(\r\n        requirement.type,\r\n        product.category\r\n      );\r\n    }\r\n\r\n    // Overall semantic similarity\r\n    const reqText = `${requirement.finish || ''} ${requirement.type || ''} ${requirement.coverage || ''} ${requirement.durability || ''}`;\r\n    const prodText = `${product.finish || ''} ${product.category || ''} ${product.coverage || ''} ${product.durability || ''}`;\r\n    \r\n    scores.overallSimilarity = this.calculateTextSimilarity(reqText, prodText);\r\n\r\n    return scores;\r\n  }\r\n\r\n  // Fuzzy string matching (Levenshtein distance)\r\n  levenshteinDistance(str1, str2) {\r\n    const len1 = str1.length;\r\n    const len2 = str2.length;\r\n    const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\r\n\r\n    for (let i = 0; i <= len1; i++) matrix[i][0] = i;\r\n    for (let j = 0; j <= len2; j++) matrix[0][j] = j;\r\n\r\n    for (let i = 1; i <= len1; i++) {\r\n      for (let j = 1; j <= len2; j++) {\r\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j] + 1,      // deletion\r\n          matrix[i][j - 1] + 1,      // insertion\r\n          matrix[i - 1][j - 1] + cost // substitution\r\n        );\r\n      }\r\n    }\r\n\r\n    return matrix[len1][len2];\r\n  }\r\n\r\n  // Fuzzy match score (0-1 scale)\r\n  fuzzyMatchScore(str1, str2) {\r\n    const distance = this.levenshteinDistance(\r\n      str1.toLowerCase(),\r\n      str2.toLowerCase()\r\n    );\r\n    const maxLen = Math.max(str1.length, str2.length);\r\n    return maxLen > 0 ? 1 - (distance / maxLen) : 0;\r\n  }\r\n\r\n  // Synonym detection for paint industry terms\r\n  getSynonyms(term) {\r\n    const synonymMap = {\r\n      'matt': ['matte', 'flat', 'non-glossy'],\r\n      'silk': ['satin', 'semi-gloss', 'eggshell'],\r\n      'gloss': ['glossy', 'shiny', 'high-gloss'],\r\n      'exterior': ['external', 'outdoor', 'outside'],\r\n      'interior': ['internal', 'indoor', 'inside'],\r\n      'weather-resistant': ['weatherproof', 'weather-proof', 'all-weather'],\r\n      'durable': ['long-lasting', 'hard-wearing', 'robust'],\r\n      'coverage': ['spread', 'covering', 'application-rate'],\r\n      'emulsion': ['paint', 'coating', 'finish']\r\n    };\r\n\r\n    const lowerTerm = term.toLowerCase();\r\n    \r\n    // Check if term is a key\r\n    if (synonymMap[lowerTerm]) {\r\n      return [lowerTerm, ...synonymMap[lowerTerm]];\r\n    }\r\n\r\n    // Check if term is in any synonym list\r\n    for (const [key, synonyms] of Object.entries(synonymMap)) {\r\n      if (synonyms.includes(lowerTerm)) {\r\n        return [key, ...synonyms];\r\n      }\r\n    }\r\n\r\n    return [lowerTerm];\r\n  }\r\n\r\n  // Enhanced matching with synonym support\r\n  matchWithSynonyms(term1, term2) {\r\n    const synonyms1 = this.getSynonyms(term1);\r\n    const synonyms2 = this.getSynonyms(term2);\r\n\r\n    // Check for exact match in synonym lists\r\n    for (const syn1 of synonyms1) {\r\n      for (const syn2 of synonyms2) {\r\n        if (syn1 === syn2) {\r\n          return { match: true, score: 1.0, type: 'exact' };\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for fuzzy match\r\n    let bestScore = 0;\r\n    for (const syn1 of synonyms1) {\r\n      for (const syn2 of synonyms2) {\r\n        const score = this.fuzzyMatchScore(syn1, syn2);\r\n        if (score > bestScore) {\r\n          bestScore = score;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (bestScore > 0.8) {\r\n      return { match: true, score: bestScore, type: 'fuzzy' };\r\n    }\r\n\r\n    return { match: false, score: bestScore, type: 'none' };\r\n  }\r\n\r\n  // Jaccard similarity for set-based comparison\r\n  jaccardSimilarity(set1, set2) {\r\n    const intersection = new Set([...set1].filter(x => set2.has(x)));\r\n    const union = new Set([...set1, ...set2]);\r\n    \r\n    return union.size > 0 ? intersection.size / union.size : 0;\r\n  }\r\n\r\n  // Extract keywords from text\r\n  extractKeywords(text) {\r\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by']);\r\n    const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2 && !stopWords.has(w));\r\n    return new Set(words);\r\n  }\r\n\r\n  // Keyword-based similarity\r\n  keywordSimilarity(text1, text2) {\r\n    const keywords1 = this.extractKeywords(text1);\r\n    const keywords2 = this.extractKeywords(text2);\r\n    return this.jaccardSimilarity(keywords1, keywords2);\r\n  }\r\n\r\n  // Comprehensive similarity score combining multiple methods\r\n  comprehensiveSimilarity(text1, text2) {\r\n    const cosine = this.calculateTextSimilarity(text1, text2);\r\n    const keyword = this.keywordSimilarity(text1, text2);\r\n    const fuzzy = this.fuzzyMatchScore(text1, text2);\r\n\r\n    // Weighted combination\r\n    return {\r\n      cosine: cosine,\r\n      keyword: keyword,\r\n      fuzzy: fuzzy,\r\n      combined: (cosine * 0.5 + keyword * 0.3 + fuzzy * 0.2),\r\n      breakdown: {\r\n        'Cosine Similarity': `${(cosine * 100).toFixed(1)}%`,\r\n        'Keyword Match': `${(keyword * 100).toFixed(1)}%`,\r\n        'Fuzzy Match': `${(fuzzy * 100).toFixed(1)}%`\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const semanticMatcher = new SemanticMatcher();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}