{"ast":null,"code":"import _objectSpread from\"C:/Users/BIT/Downloads/RFP/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";// Product Knowledge Graph - Semantic relationships between products\nexport class ProductKnowledgeGraph{constructor(){this.nodes=new Map();this.edges=new Map();this.relationships={COMPATIBLE_WITH:'compatible_with',ALTERNATIVE_TO:'alternative_to',REQUIRES:'requires',USED_WITH:'used_with',CATEGORY:'category',MATERIAL:'material',FINISH:'finish',APPLICATION:'application'};}// Add a product node to the graph\naddProduct(product){const nodeId=product.id;this.nodes.set(nodeId,{id:nodeId,type:'product',data:product,properties:{name:product.name,category:product.category,finish:product.finish,material:product.material||'paint',vendor:product.vendor}});// Initialize edges for this node\nif(!this.edges.has(nodeId)){this.edges.set(nodeId,[]);}}// Add a relationship between two products\naddRelationship(fromProductId,toProductId,relationshipType){let weight=arguments.length>3&&arguments[3]!==undefined?arguments[3]:1.0;const edge={from:fromProductId,to:toProductId,type:relationshipType,weight:weight};if(!this.edges.has(fromProductId)){this.edges.set(fromProductId,[]);}this.edges.get(fromProductId).push(edge);}// Find products by category\nfindByCategory(category){const results=[];for(const[,node]of this.nodes){var _node$properties$cate;if(((_node$properties$cate=node.properties.category)===null||_node$properties$cate===void 0?void 0:_node$properties$cate.toLowerCase())===category.toLowerCase()){results.push(node.data);}}return results;}// Find products by finish\nfindByFinish(finish){const results=[];for(const[,node]of this.nodes){var _node$properties$fini;if(((_node$properties$fini=node.properties.finish)===null||_node$properties$fini===void 0?void 0:_node$properties$fini.toLowerCase())===finish.toLowerCase()){results.push(node.data);}}return results;}// Find compatible products\nfindCompatibleProducts(productId){const compatibleProducts=[];const edges=this.edges.get(productId)||[];edges.forEach(edge=>{if(edge.type===this.relationships.COMPATIBLE_WITH||edge.type===this.relationships.ALTERNATIVE_TO){const product=this.nodes.get(edge.to);if(product){compatibleProducts.push({product:product.data,relationshipType:edge.type,weight:edge.weight});}}});return compatibleProducts;}// Find products that require this product\nfindDependentProducts(productId){const dependents=[];for(const[nodeId,edges]of this.edges){edges.forEach(edge=>{if(edge.to===productId&&edge.type===this.relationships.REQUIRES){const product=this.nodes.get(nodeId);if(product){dependents.push(product.data);}}});}return dependents;}// Semantic search - find products matching multiple criteria\nsemanticSearch(criteria){const results=[];for(const[,node]of this.nodes){var _node$properties$cate2,_node$properties$fini2,_node$properties$mate,_node$properties$vend;let score=0;let matches=0;// Category match\nif(criteria.category&&((_node$properties$cate2=node.properties.category)===null||_node$properties$cate2===void 0?void 0:_node$properties$cate2.toLowerCase())===criteria.category.toLowerCase()){score+=30;matches++;}// Finish match\nif(criteria.finish&&((_node$properties$fini2=node.properties.finish)===null||_node$properties$fini2===void 0?void 0:_node$properties$fini2.toLowerCase())===criteria.finish.toLowerCase()){score+=25;matches++;}// Material match\nif(criteria.material&&((_node$properties$mate=node.properties.material)===null||_node$properties$mate===void 0?void 0:_node$properties$mate.toLowerCase())===criteria.material.toLowerCase()){score+=20;matches++;}// Vendor match\nif(criteria.vendor&&((_node$properties$vend=node.properties.vendor)===null||_node$properties$vend===void 0?void 0:_node$properties$vend.toLowerCase())===criteria.vendor.toLowerCase()){score+=15;matches++;}// Coverage match\nif(criteria.minCoverage&&node.data.coverage>=criteria.minCoverage){score+=10;matches++;}if(matches>0){results.push({product:node.data,score:score,matchCount:matches});}}// Sort by score\nreturn results.sort((a,b)=>b.score-a.score);}// Find shortest path between two products (for recommendations)\nfindPath(fromProductId,toProductId){let maxDepth=arguments.length>2&&arguments[2]!==undefined?arguments[2]:3;const visited=new Set();const queue=[[fromProductId]];while(queue.length>0){const path=queue.shift();const currentNode=path[path.length-1];if(currentNode===toProductId){return path.map(id=>{var _this$nodes$get;return(_this$nodes$get=this.nodes.get(id))===null||_this$nodes$get===void 0?void 0:_this$nodes$get.data;});}if(path.length>=maxDepth){continue;}if(visited.has(currentNode)){continue;}visited.add(currentNode);const edges=this.edges.get(currentNode)||[];edges.forEach(edge=>{if(!visited.has(edge.to)){queue.push([...path,edge.to]);}});}return null;// No path found\n}// Get product recommendations based on current selection\ngetRecommendations(productId){let limit=arguments.length>1&&arguments[1]!==undefined?arguments[1]:5;const recommendations=[];const product=this.nodes.get(productId);if(!product)return recommendations;// Find compatible products\nconst compatible=this.findCompatibleProducts(productId);recommendations.push(...compatible);// Find products in same category\nconst sameCategory=this.findByCategory(product.properties.category);sameCategory.forEach(p=>{if(p.id!==productId&&!recommendations.some(r=>{var _r$product;return((_r$product=r.product)===null||_r$product===void 0?void 0:_r$product.id)===p.id;})){recommendations.push({product:p,relationshipType:'same_category',weight:0.7});}});// Sort by weight and limit\nreturn recommendations.sort((a,b)=>b.weight-a.weight).slice(0,limit);}// Analyze product clusters\nfindClusters(){const clusters=new Map();for(const[,node]of this.nodes){const category=node.properties.category||'uncategorized';if(!clusters.has(category)){clusters.set(category,[]);}clusters.get(category).push(node.data);}return clusters;}// Get graph statistics\ngetStatistics(){const stats={totalProducts:this.nodes.size,totalRelationships:0,categories:new Set(),vendors:new Set(),avgConnectionsPerProduct:0};for(const[,node]of this.nodes){if(node.properties.category)stats.categories.add(node.properties.category);if(node.properties.vendor)stats.vendors.add(node.properties.vendor);}for(const[,edges]of this.edges){stats.totalRelationships+=edges.length;}stats.avgConnectionsPerProduct=stats.totalRelationships/this.nodes.size||0;return _objectSpread(_objectSpread({},stats),{},{categories:Array.from(stats.categories),vendors:Array.from(stats.vendors)});}// Export graph for visualization\nexportGraph(){const nodes=[];const links=[];for(const[id,node]of this.nodes){nodes.push({id:id,name:node.properties.name,category:node.properties.category,vendor:node.properties.vendor});}for(const[fromId,edges]of this.edges){edges.forEach(edge=>{links.push({source:fromId,target:edge.to,type:edge.type,weight:edge.weight});});}return{nodes,links};}}// Create and initialize knowledge graph\nexport const productKnowledgeGraph=new ProductKnowledgeGraph();// Helper function to build graph from product repository\nexport function buildKnowledgeGraph(productRepository){// Add all products as nodes\nObject.entries(productRepository).forEach(_ref=>{let[vendorName,products]=_ref;products.forEach(product=>{productKnowledgeGraph.addProduct(_objectSpread(_objectSpread({},product),{},{vendor:vendorName}));});});// Add relationships based on properties\nconst allProducts=[];Object.entries(productRepository).forEach(_ref2=>{let[vendorName,products]=_ref2;products.forEach(product=>{allProducts.push(_objectSpread(_objectSpread({},product),{},{vendor:vendorName}));});});// Create relationships\nallProducts.forEach((product1,i)=>{allProducts.forEach((product2,j)=>{if(i>=j)return;// Avoid duplicates and self-references\n// Same category = compatible\nif(product1.category===product2.category){productKnowledgeGraph.addRelationship(product1.id,product2.id,productKnowledgeGraph.relationships.COMPATIBLE_WITH,0.8);}// Same finish = alternative\nif(product1.finish===product2.finish&&product1.category===product2.category){productKnowledgeGraph.addRelationship(product1.id,product2.id,productKnowledgeGraph.relationships.ALTERNATIVE_TO,0.9);}// Different categories but complementary\nif(product1.category==='Exterior'&&product2.category==='Interior'){productKnowledgeGraph.addRelationship(product1.id,product2.id,productKnowledgeGraph.relationships.USED_WITH,0.6);}});});return productKnowledgeGraph;}","map":{"version":3,"names":["ProductKnowledgeGraph","constructor","nodes","Map","edges","relationships","COMPATIBLE_WITH","ALTERNATIVE_TO","REQUIRES","USED_WITH","CATEGORY","MATERIAL","FINISH","APPLICATION","addProduct","product","nodeId","id","set","type","data","properties","name","category","finish","material","vendor","has","addRelationship","fromProductId","toProductId","relationshipType","weight","arguments","length","undefined","edge","from","to","get","push","findByCategory","results","node","_node$properties$cate","toLowerCase","findByFinish","_node$properties$fini","findCompatibleProducts","productId","compatibleProducts","forEach","findDependentProducts","dependents","semanticSearch","criteria","_node$properties$cate2","_node$properties$fini2","_node$properties$mate","_node$properties$vend","score","matches","minCoverage","coverage","matchCount","sort","a","b","findPath","maxDepth","visited","Set","queue","path","shift","currentNode","map","_this$nodes$get","add","getRecommendations","limit","recommendations","compatible","sameCategory","p","some","r","_r$product","slice","findClusters","clusters","getStatistics","stats","totalProducts","size","totalRelationships","categories","vendors","avgConnectionsPerProduct","_objectSpread","Array","exportGraph","links","fromId","source","target","productKnowledgeGraph","buildKnowledgeGraph","productRepository","Object","entries","_ref","vendorName","products","allProducts","_ref2","product1","i","product2","j"],"sources":["C:/Users/BIT/Downloads/RFP/src/utils/ProductKnowledgeGraph.js"],"sourcesContent":["// Product Knowledge Graph - Semantic relationships between products\r\nexport class ProductKnowledgeGraph {\r\n  constructor() {\r\n    this.nodes = new Map();\r\n    this.edges = new Map();\r\n    this.relationships = {\r\n      COMPATIBLE_WITH: 'compatible_with',\r\n      ALTERNATIVE_TO: 'alternative_to',\r\n      REQUIRES: 'requires',\r\n      USED_WITH: 'used_with',\r\n      CATEGORY: 'category',\r\n      MATERIAL: 'material',\r\n      FINISH: 'finish',\r\n      APPLICATION: 'application'\r\n    };\r\n  }\r\n  \r\n  // Add a product node to the graph\r\n  addProduct(product) {\r\n    const nodeId = product.id;\r\n    this.nodes.set(nodeId, {\r\n      id: nodeId,\r\n      type: 'product',\r\n      data: product,\r\n      properties: {\r\n        name: product.name,\r\n        category: product.category,\r\n        finish: product.finish,\r\n        material: product.material || 'paint',\r\n        vendor: product.vendor\r\n      }\r\n    });\r\n    \r\n    // Initialize edges for this node\r\n    if (!this.edges.has(nodeId)) {\r\n      this.edges.set(nodeId, []);\r\n    }\r\n  }\r\n  \r\n  // Add a relationship between two products\r\n  addRelationship(fromProductId, toProductId, relationshipType, weight = 1.0) {\r\n    const edge = {\r\n      from: fromProductId,\r\n      to: toProductId,\r\n      type: relationshipType,\r\n      weight: weight\r\n    };\r\n    \r\n    if (!this.edges.has(fromProductId)) {\r\n      this.edges.set(fromProductId, []);\r\n    }\r\n    \r\n    this.edges.get(fromProductId).push(edge);\r\n  }\r\n  \r\n  // Find products by category\r\n  findByCategory(category) {\r\n    const results = [];\r\n    for (const [, node] of this.nodes) {\r\n      if (node.properties.category?.toLowerCase() === category.toLowerCase()) {\r\n        results.push(node.data);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  \r\n  // Find products by finish\r\n  findByFinish(finish) {\r\n    const results = [];\r\n    for (const [, node] of this.nodes) {\r\n      if (node.properties.finish?.toLowerCase() === finish.toLowerCase()) {\r\n        results.push(node.data);\r\n      }\r\n    }\r\n    return results;\r\n  }\r\n  \r\n  // Find compatible products\r\n  findCompatibleProducts(productId) {\r\n    const compatibleProducts = [];\r\n    const edges = this.edges.get(productId) || [];\r\n    \r\n    edges.forEach(edge => {\r\n      if (edge.type === this.relationships.COMPATIBLE_WITH || \r\n          edge.type === this.relationships.ALTERNATIVE_TO) {\r\n        const product = this.nodes.get(edge.to);\r\n        if (product) {\r\n          compatibleProducts.push({\r\n            product: product.data,\r\n            relationshipType: edge.type,\r\n            weight: edge.weight\r\n          });\r\n        }\r\n      }\r\n    });\r\n    \r\n    return compatibleProducts;\r\n  }\r\n  \r\n  // Find products that require this product\r\n  findDependentProducts(productId) {\r\n    const dependents = [];\r\n    \r\n    for (const [nodeId, edges] of this.edges) {\r\n      edges.forEach(edge => {\r\n        if (edge.to === productId && edge.type === this.relationships.REQUIRES) {\r\n          const product = this.nodes.get(nodeId);\r\n          if (product) {\r\n            dependents.push(product.data);\r\n          }\r\n        }\r\n      });\r\n    }\r\n    \r\n    return dependents;\r\n  }\r\n  \r\n  // Semantic search - find products matching multiple criteria\r\n  semanticSearch(criteria) {\r\n    const results = [];\r\n    \r\n    for (const [, node] of this.nodes) {\r\n      let score = 0;\r\n      let matches = 0;\r\n      \r\n      // Category match\r\n      if (criteria.category && node.properties.category?.toLowerCase() === criteria.category.toLowerCase()) {\r\n        score += 30;\r\n        matches++;\r\n      }\r\n      \r\n      // Finish match\r\n      if (criteria.finish && node.properties.finish?.toLowerCase() === criteria.finish.toLowerCase()) {\r\n        score += 25;\r\n        matches++;\r\n      }\r\n      \r\n      // Material match\r\n      if (criteria.material && node.properties.material?.toLowerCase() === criteria.material.toLowerCase()) {\r\n        score += 20;\r\n        matches++;\r\n      }\r\n      \r\n      // Vendor match\r\n      if (criteria.vendor && node.properties.vendor?.toLowerCase() === criteria.vendor.toLowerCase()) {\r\n        score += 15;\r\n        matches++;\r\n      }\r\n      \r\n      // Coverage match\r\n      if (criteria.minCoverage && node.data.coverage >= criteria.minCoverage) {\r\n        score += 10;\r\n        matches++;\r\n      }\r\n      \r\n      if (matches > 0) {\r\n        results.push({\r\n          product: node.data,\r\n          score: score,\r\n          matchCount: matches\r\n        });\r\n      }\r\n    }\r\n    \r\n    // Sort by score\r\n    return results.sort((a, b) => b.score - a.score);\r\n  }\r\n  \r\n  // Find shortest path between two products (for recommendations)\r\n  findPath(fromProductId, toProductId, maxDepth = 3) {\r\n    const visited = new Set();\r\n    const queue = [[fromProductId]];\r\n    \r\n    while (queue.length > 0) {\r\n      const path = queue.shift();\r\n      const currentNode = path[path.length - 1];\r\n      \r\n      if (currentNode === toProductId) {\r\n        return path.map(id => this.nodes.get(id)?.data);\r\n      }\r\n      \r\n      if (path.length >= maxDepth) {\r\n        continue;\r\n      }\r\n      \r\n      if (visited.has(currentNode)) {\r\n        continue;\r\n      }\r\n      \r\n      visited.add(currentNode);\r\n      \r\n      const edges = this.edges.get(currentNode) || [];\r\n      edges.forEach(edge => {\r\n        if (!visited.has(edge.to)) {\r\n          queue.push([...path, edge.to]);\r\n        }\r\n      });\r\n    }\r\n    \r\n    return null; // No path found\r\n  }\r\n  \r\n  // Get product recommendations based on current selection\r\n  getRecommendations(productId, limit = 5) {\r\n    const recommendations = [];\r\n    const product = this.nodes.get(productId);\r\n    \r\n    if (!product) return recommendations;\r\n    \r\n    // Find compatible products\r\n    const compatible = this.findCompatibleProducts(productId);\r\n    recommendations.push(...compatible);\r\n    \r\n    // Find products in same category\r\n    const sameCategory = this.findByCategory(product.properties.category);\r\n    sameCategory.forEach(p => {\r\n      if (p.id !== productId && !recommendations.some(r => r.product?.id === p.id)) {\r\n        recommendations.push({\r\n          product: p,\r\n          relationshipType: 'same_category',\r\n          weight: 0.7\r\n        });\r\n      }\r\n    });\r\n    \r\n    // Sort by weight and limit\r\n    return recommendations\r\n      .sort((a, b) => b.weight - a.weight)\r\n      .slice(0, limit);\r\n  }\r\n  \r\n  // Analyze product clusters\r\n  findClusters() {\r\n    const clusters = new Map();\r\n    \r\n    for (const [, node] of this.nodes) {\r\n      const category = node.properties.category || 'uncategorized';\r\n      \r\n      if (!clusters.has(category)) {\r\n        clusters.set(category, []);\r\n      }\r\n      \r\n      clusters.get(category).push(node.data);\r\n    }\r\n    \r\n    return clusters;\r\n  }\r\n  \r\n  // Get graph statistics\r\n  getStatistics() {\r\n    const stats = {\r\n      totalProducts: this.nodes.size,\r\n      totalRelationships: 0,\r\n      categories: new Set(),\r\n      vendors: new Set(),\r\n      avgConnectionsPerProduct: 0\r\n    };\r\n    \r\n    for (const [, node] of this.nodes) {\r\n      if (node.properties.category) stats.categories.add(node.properties.category);\r\n      if (node.properties.vendor) stats.vendors.add(node.properties.vendor);\r\n    }\r\n    \r\n    for (const [, edges] of this.edges) {\r\n      stats.totalRelationships += edges.length;\r\n    }\r\n    \r\n    stats.avgConnectionsPerProduct = stats.totalRelationships / this.nodes.size || 0;\r\n    \r\n    return {\r\n      ...stats,\r\n      categories: Array.from(stats.categories),\r\n      vendors: Array.from(stats.vendors)\r\n    };\r\n  }\r\n  \r\n  // Export graph for visualization\r\n  exportGraph() {\r\n    const nodes = [];\r\n    const links = [];\r\n    \r\n    for (const [id, node] of this.nodes) {\r\n      nodes.push({\r\n        id: id,\r\n        name: node.properties.name,\r\n        category: node.properties.category,\r\n        vendor: node.properties.vendor\r\n      });\r\n    }\r\n    \r\n    for (const [fromId, edges] of this.edges) {\r\n      edges.forEach(edge => {\r\n        links.push({\r\n          source: fromId,\r\n          target: edge.to,\r\n          type: edge.type,\r\n          weight: edge.weight\r\n        });\r\n      });\r\n    }\r\n    \r\n    return { nodes, links };\r\n  }\r\n}\r\n\r\n// Create and initialize knowledge graph\r\nexport const productKnowledgeGraph = new ProductKnowledgeGraph();\r\n\r\n// Helper function to build graph from product repository\r\nexport function buildKnowledgeGraph(productRepository) {\r\n  // Add all products as nodes\r\n  Object.entries(productRepository).forEach(([vendorName, products]) => {\r\n    products.forEach(product => {\r\n      productKnowledgeGraph.addProduct({\r\n        ...product,\r\n        vendor: vendorName\r\n      });\r\n    });\r\n  });\r\n  \r\n  // Add relationships based on properties\r\n  const allProducts = [];\r\n  Object.entries(productRepository).forEach(([vendorName, products]) => {\r\n    products.forEach(product => {\r\n      allProducts.push({ ...product, vendor: vendorName });\r\n    });\r\n  });\r\n  \r\n  // Create relationships\r\n  allProducts.forEach((product1, i) => {\r\n    allProducts.forEach((product2, j) => {\r\n      if (i >= j) return; // Avoid duplicates and self-references\r\n      \r\n      // Same category = compatible\r\n      if (product1.category === product2.category) {\r\n        productKnowledgeGraph.addRelationship(\r\n          product1.id,\r\n          product2.id,\r\n          productKnowledgeGraph.relationships.COMPATIBLE_WITH,\r\n          0.8\r\n        );\r\n      }\r\n      \r\n      // Same finish = alternative\r\n      if (product1.finish === product2.finish && product1.category === product2.category) {\r\n        productKnowledgeGraph.addRelationship(\r\n          product1.id,\r\n          product2.id,\r\n          productKnowledgeGraph.relationships.ALTERNATIVE_TO,\r\n          0.9\r\n        );\r\n      }\r\n      \r\n      // Different categories but complementary\r\n      if (product1.category === 'Exterior' && product2.category === 'Interior') {\r\n        productKnowledgeGraph.addRelationship(\r\n          product1.id,\r\n          product2.id,\r\n          productKnowledgeGraph.relationships.USED_WITH,\r\n          0.6\r\n        );\r\n      }\r\n    });\r\n  });\r\n  \r\n  return productKnowledgeGraph;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}