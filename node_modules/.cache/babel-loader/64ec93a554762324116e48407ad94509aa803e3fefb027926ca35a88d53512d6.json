{"ast":null,"code":"// Semantic Matcher - Advanced similarity calculations\nexport class SemanticMatcher{constructor(){this.name=\"Semantic Matcher\";}// Cosine Similarity - Core algorithm for semantic matching\ncosineSimilarity(vecA,vecB){if(vecA.length!==vecB.length){throw new Error('Vectors must have the same length');}const dotProduct=vecA.reduce((sum,a,i)=>sum+a*vecB[i],0);const magA=Math.sqrt(vecA.reduce((sum,a)=>sum+a*a,0));const magB=Math.sqrt(vecB.reduce((sum,b)=>sum+b*b,0));if(magA===0||magB===0)return 0;return dotProduct/(magA*magB);}// Convert text to simple feature vector (TF-IDF-like approach)\ntextToVector(text,vocabulary){const words=text.toLowerCase().split(/\\W+/).filter(w=>w.length>2);const vector=new Array(vocabulary.length).fill(0);words.forEach(word=>{const index=vocabulary.indexOf(word);if(index!==-1){vector[index]++;}});// Normalize vector\nconst magnitude=Math.sqrt(vector.reduce((sum,val)=>sum+val*val,0));return magnitude>0?vector.map(v=>v/magnitude):vector;}// Build vocabulary from corpus\nbuildVocabulary(texts){const allWords=new Set();texts.forEach(text=>{const words=text.toLowerCase().split(/\\W+/).filter(w=>w.length>2);words.forEach(word=>allWords.add(word));});return Array.from(allWords).sort();}// Semantic similarity between two texts\ncalculateTextSimilarity(text1,text2){const vocabulary=this.buildVocabulary([text1,text2]);const vec1=this.textToVector(text1,vocabulary);const vec2=this.textToVector(text2,vocabulary);return this.cosineSimilarity(vec1,vec2);}// Enhanced spec matching with semantic similarity\nsemanticSpecMatch(requirement,product){const scores={finishSimilarity:0,categorySimilarity:0,overallSimilarity:0};// Finish type semantic matching\nif(requirement.finish&&product.finish){scores.finishSimilarity=this.calculateTextSimilarity(requirement.finish,product.finish);}// Category semantic matching\nif(requirement.type&&product.category){scores.categorySimilarity=this.calculateTextSimilarity(requirement.type,product.category);}// Overall semantic similarity\nconst reqText=\"\".concat(requirement.finish||'',\" \").concat(requirement.type||'',\" \").concat(requirement.coverage||'',\" \").concat(requirement.durability||'');const prodText=\"\".concat(product.finish||'',\" \").concat(product.category||'',\" \").concat(product.coverage||'',\" \").concat(product.durability||'');scores.overallSimilarity=this.calculateTextSimilarity(reqText,prodText);return scores;}// Fuzzy string matching (Levenshtein distance)\nlevenshteinDistance(str1,str2){const len1=str1.length;const len2=str2.length;const matrix=Array(len1+1).fill(null).map(()=>Array(len2+1).fill(0));for(let i=0;i<=len1;i++)matrix[i][0]=i;for(let j=0;j<=len2;j++)matrix[0][j]=j;for(let i=1;i<=len1;i++){for(let j=1;j<=len2;j++){const cost=str1[i-1]===str2[j-1]?0:1;matrix[i][j]=Math.min(matrix[i-1][j]+1,// deletion\nmatrix[i][j-1]+1,// insertion\nmatrix[i-1][j-1]+cost// substitution\n);}}return matrix[len1][len2];}// Fuzzy match score (0-1 scale)\nfuzzyMatchScore(str1,str2){const distance=this.levenshteinDistance(str1.toLowerCase(),str2.toLowerCase());const maxLen=Math.max(str1.length,str2.length);return maxLen>0?1-distance/maxLen:0;}// Synonym detection for paint industry terms\ngetSynonyms(term){const synonymMap={'matt':['matte','flat','non-glossy'],'silk':['satin','semi-gloss','eggshell'],'gloss':['glossy','shiny','high-gloss'],'exterior':['external','outdoor','outside'],'interior':['internal','indoor','inside'],'weather-resistant':['weatherproof','weather-proof','all-weather'],'durable':['long-lasting','hard-wearing','robust'],'coverage':['spread','covering','application-rate'],'emulsion':['paint','coating','finish']};const lowerTerm=term.toLowerCase();// Check if term is a key\nif(synonymMap[lowerTerm]){return[lowerTerm,...synonymMap[lowerTerm]];}// Check if term is in any synonym list\nfor(const[key,synonyms]of Object.entries(synonymMap)){if(synonyms.includes(lowerTerm)){return[key,...synonyms];}}return[lowerTerm];}// Enhanced matching with synonym support\nmatchWithSynonyms(term1,term2){const synonyms1=this.getSynonyms(term1);const synonyms2=this.getSynonyms(term2);// Check for exact match in synonym lists\nfor(const syn1 of synonyms1){for(const syn2 of synonyms2){if(syn1===syn2){return{match:true,score:1.0,type:'exact'};}}}// Check for fuzzy match\nlet bestScore=0;for(const syn1 of synonyms1){for(const syn2 of synonyms2){const score=this.fuzzyMatchScore(syn1,syn2);if(score>bestScore){bestScore=score;}}}if(bestScore>0.8){return{match:true,score:bestScore,type:'fuzzy'};}return{match:false,score:bestScore,type:'none'};}// Jaccard similarity for set-based comparison\njaccardSimilarity(set1,set2){const intersection=new Set([...set1].filter(x=>set2.has(x)));const union=new Set([...set1,...set2]);return union.size>0?intersection.size/union.size:0;}// Extract keywords from text\nextractKeywords(text){const stopWords=new Set(['the','a','an','and','or','but','in','on','at','to','for','of','with','by']);const words=text.toLowerCase().split(/\\W+/).filter(w=>w.length>2&&!stopWords.has(w));return new Set(words);}// Keyword-based similarity\nkeywordSimilarity(text1,text2){const keywords1=this.extractKeywords(text1);const keywords2=this.extractKeywords(text2);return this.jaccardSimilarity(keywords1,keywords2);}// Comprehensive similarity score combining multiple methods\ncomprehensiveSimilarity(text1,text2){const cosine=this.calculateTextSimilarity(text1,text2);const keyword=this.keywordSimilarity(text1,text2);const fuzzy=this.fuzzyMatchScore(text1,text2);// Weighted combination\nreturn{cosine:cosine,keyword:keyword,fuzzy:fuzzy,combined:cosine*0.5+keyword*0.3+fuzzy*0.2,breakdown:{'Cosine Similarity':\"\".concat((cosine*100).toFixed(1),\"%\"),'Keyword Match':\"\".concat((keyword*100).toFixed(1),\"%\"),'Fuzzy Match':\"\".concat((fuzzy*100).toFixed(1),\"%\")}};}}// Create singleton instance\nexport const semanticMatcher=new SemanticMatcher();","map":{"version":3,"names":["SemanticMatcher","constructor","name","cosineSimilarity","vecA","vecB","length","Error","dotProduct","reduce","sum","a","i","magA","Math","sqrt","magB","b","textToVector","text","vocabulary","words","toLowerCase","split","filter","w","vector","Array","fill","forEach","word","index","indexOf","magnitude","val","map","v","buildVocabulary","texts","allWords","Set","add","from","sort","calculateTextSimilarity","text1","text2","vec1","vec2","semanticSpecMatch","requirement","product","scores","finishSimilarity","categorySimilarity","overallSimilarity","finish","type","category","reqText","concat","coverage","durability","prodText","levenshteinDistance","str1","str2","len1","len2","matrix","j","cost","min","fuzzyMatchScore","distance","maxLen","max","getSynonyms","term","synonymMap","lowerTerm","key","synonyms","Object","entries","includes","matchWithSynonyms","term1","term2","synonyms1","synonyms2","syn1","syn2","match","score","bestScore","jaccardSimilarity","set1","set2","intersection","x","has","union","size","extractKeywords","stopWords","keywordSimilarity","keywords1","keywords2","comprehensiveSimilarity","cosine","keyword","fuzzy","combined","breakdown","toFixed","semanticMatcher"],"sources":["C:/Users/BIT/Downloads/RFP/src/utils/SemanticMatcher.js"],"sourcesContent":["// Semantic Matcher - Advanced similarity calculations\r\nexport class SemanticMatcher {\r\n  constructor() {\r\n    this.name = \"Semantic Matcher\";\r\n  }\r\n\r\n  // Cosine Similarity - Core algorithm for semantic matching\r\n  cosineSimilarity(vecA, vecB) {\r\n    if (vecA.length !== vecB.length) {\r\n      throw new Error('Vectors must have the same length');\r\n    }\r\n\r\n    const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);\r\n    const magA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));\r\n    const magB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));\r\n\r\n    if (magA === 0 || magB === 0) return 0;\r\n    \r\n    return dotProduct / (magA * magB);\r\n  }\r\n\r\n  // Convert text to simple feature vector (TF-IDF-like approach)\r\n  textToVector(text, vocabulary) {\r\n    const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2);\r\n    const vector = new Array(vocabulary.length).fill(0);\r\n    \r\n    words.forEach(word => {\r\n      const index = vocabulary.indexOf(word);\r\n      if (index !== -1) {\r\n        vector[index]++;\r\n      }\r\n    });\r\n    \r\n    // Normalize vector\r\n    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\r\n    return magnitude > 0 ? vector.map(v => v / magnitude) : vector;\r\n  }\r\n\r\n  // Build vocabulary from corpus\r\n  buildVocabulary(texts) {\r\n    const allWords = new Set();\r\n    \r\n    texts.forEach(text => {\r\n      const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2);\r\n      words.forEach(word => allWords.add(word));\r\n    });\r\n    \r\n    return Array.from(allWords).sort();\r\n  }\r\n\r\n  // Semantic similarity between two texts\r\n  calculateTextSimilarity(text1, text2) {\r\n    const vocabulary = this.buildVocabulary([text1, text2]);\r\n    const vec1 = this.textToVector(text1, vocabulary);\r\n    const vec2 = this.textToVector(text2, vocabulary);\r\n    \r\n    return this.cosineSimilarity(vec1, vec2);\r\n  }\r\n\r\n  // Enhanced spec matching with semantic similarity\r\n  semanticSpecMatch(requirement, product) {\r\n    const scores = {\r\n      finishSimilarity: 0,\r\n      categorySimilarity: 0,\r\n      overallSimilarity: 0\r\n    };\r\n\r\n    // Finish type semantic matching\r\n    if (requirement.finish && product.finish) {\r\n      scores.finishSimilarity = this.calculateTextSimilarity(\r\n        requirement.finish,\r\n        product.finish\r\n      );\r\n    }\r\n\r\n    // Category semantic matching\r\n    if (requirement.type && product.category) {\r\n      scores.categorySimilarity = this.calculateTextSimilarity(\r\n        requirement.type,\r\n        product.category\r\n      );\r\n    }\r\n\r\n    // Overall semantic similarity\r\n    const reqText = `${requirement.finish || ''} ${requirement.type || ''} ${requirement.coverage || ''} ${requirement.durability || ''}`;\r\n    const prodText = `${product.finish || ''} ${product.category || ''} ${product.coverage || ''} ${product.durability || ''}`;\r\n    \r\n    scores.overallSimilarity = this.calculateTextSimilarity(reqText, prodText);\r\n\r\n    return scores;\r\n  }\r\n\r\n  // Fuzzy string matching (Levenshtein distance)\r\n  levenshteinDistance(str1, str2) {\r\n    const len1 = str1.length;\r\n    const len2 = str2.length;\r\n    const matrix = Array(len1 + 1).fill(null).map(() => Array(len2 + 1).fill(0));\r\n\r\n    for (let i = 0; i <= len1; i++) matrix[i][0] = i;\r\n    for (let j = 0; j <= len2; j++) matrix[0][j] = j;\r\n\r\n    for (let i = 1; i <= len1; i++) {\r\n      for (let j = 1; j <= len2; j++) {\r\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j] + 1,      // deletion\r\n          matrix[i][j - 1] + 1,      // insertion\r\n          matrix[i - 1][j - 1] + cost // substitution\r\n        );\r\n      }\r\n    }\r\n\r\n    return matrix[len1][len2];\r\n  }\r\n\r\n  // Fuzzy match score (0-1 scale)\r\n  fuzzyMatchScore(str1, str2) {\r\n    const distance = this.levenshteinDistance(\r\n      str1.toLowerCase(),\r\n      str2.toLowerCase()\r\n    );\r\n    const maxLen = Math.max(str1.length, str2.length);\r\n    return maxLen > 0 ? 1 - (distance / maxLen) : 0;\r\n  }\r\n\r\n  // Synonym detection for paint industry terms\r\n  getSynonyms(term) {\r\n    const synonymMap = {\r\n      'matt': ['matte', 'flat', 'non-glossy'],\r\n      'silk': ['satin', 'semi-gloss', 'eggshell'],\r\n      'gloss': ['glossy', 'shiny', 'high-gloss'],\r\n      'exterior': ['external', 'outdoor', 'outside'],\r\n      'interior': ['internal', 'indoor', 'inside'],\r\n      'weather-resistant': ['weatherproof', 'weather-proof', 'all-weather'],\r\n      'durable': ['long-lasting', 'hard-wearing', 'robust'],\r\n      'coverage': ['spread', 'covering', 'application-rate'],\r\n      'emulsion': ['paint', 'coating', 'finish']\r\n    };\r\n\r\n    const lowerTerm = term.toLowerCase();\r\n    \r\n    // Check if term is a key\r\n    if (synonymMap[lowerTerm]) {\r\n      return [lowerTerm, ...synonymMap[lowerTerm]];\r\n    }\r\n\r\n    // Check if term is in any synonym list\r\n    for (const [key, synonyms] of Object.entries(synonymMap)) {\r\n      if (synonyms.includes(lowerTerm)) {\r\n        return [key, ...synonyms];\r\n      }\r\n    }\r\n\r\n    return [lowerTerm];\r\n  }\r\n\r\n  // Enhanced matching with synonym support\r\n  matchWithSynonyms(term1, term2) {\r\n    const synonyms1 = this.getSynonyms(term1);\r\n    const synonyms2 = this.getSynonyms(term2);\r\n\r\n    // Check for exact match in synonym lists\r\n    for (const syn1 of synonyms1) {\r\n      for (const syn2 of synonyms2) {\r\n        if (syn1 === syn2) {\r\n          return { match: true, score: 1.0, type: 'exact' };\r\n        }\r\n      }\r\n    }\r\n\r\n    // Check for fuzzy match\r\n    let bestScore = 0;\r\n    for (const syn1 of synonyms1) {\r\n      for (const syn2 of synonyms2) {\r\n        const score = this.fuzzyMatchScore(syn1, syn2);\r\n        if (score > bestScore) {\r\n          bestScore = score;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (bestScore > 0.8) {\r\n      return { match: true, score: bestScore, type: 'fuzzy' };\r\n    }\r\n\r\n    return { match: false, score: bestScore, type: 'none' };\r\n  }\r\n\r\n  // Jaccard similarity for set-based comparison\r\n  jaccardSimilarity(set1, set2) {\r\n    const intersection = new Set([...set1].filter(x => set2.has(x)));\r\n    const union = new Set([...set1, ...set2]);\r\n    \r\n    return union.size > 0 ? intersection.size / union.size : 0;\r\n  }\r\n\r\n  // Extract keywords from text\r\n  extractKeywords(text) {\r\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by']);\r\n    const words = text.toLowerCase().split(/\\W+/).filter(w => w.length > 2 && !stopWords.has(w));\r\n    return new Set(words);\r\n  }\r\n\r\n  // Keyword-based similarity\r\n  keywordSimilarity(text1, text2) {\r\n    const keywords1 = this.extractKeywords(text1);\r\n    const keywords2 = this.extractKeywords(text2);\r\n    return this.jaccardSimilarity(keywords1, keywords2);\r\n  }\r\n\r\n  // Comprehensive similarity score combining multiple methods\r\n  comprehensiveSimilarity(text1, text2) {\r\n    const cosine = this.calculateTextSimilarity(text1, text2);\r\n    const keyword = this.keywordSimilarity(text1, text2);\r\n    const fuzzy = this.fuzzyMatchScore(text1, text2);\r\n\r\n    // Weighted combination\r\n    return {\r\n      cosine: cosine,\r\n      keyword: keyword,\r\n      fuzzy: fuzzy,\r\n      combined: (cosine * 0.5 + keyword * 0.3 + fuzzy * 0.2),\r\n      breakdown: {\r\n        'Cosine Similarity': `${(cosine * 100).toFixed(1)}%`,\r\n        'Keyword Match': `${(keyword * 100).toFixed(1)}%`,\r\n        'Fuzzy Match': `${(fuzzy * 100).toFixed(1)}%`\r\n      }\r\n    };\r\n  }\r\n}\r\n\r\n// Create singleton instance\r\nexport const semanticMatcher = new SemanticMatcher();\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}